"""Algorithm Design and Analysis Certification"""

CERTIFICATION = {
    "name": "Algorithm Design and Analysis",
    "description": "Comprehensive algorithm design patterns, complexity analysis, and optimization techniques",
    "slug": "algorithm-design-analysis",
    "level": "Expert",
    "duration": 84,
    "questions_count": 28,
    "category_slug": "data-structures-algorithms",
    "is_active": True,
}

QUESTIONS = [
    {
        "text": "What does Big O notation describe?",
        "explanation": "Big O notation describes the upper bound of an algorithm's time or space complexity in terms of input size.",
        "reference": "https://en.wikipedia.org/wiki/Big_O_notation",
        "points": 1,
        "answers": [
            {"text": "Exact runtime of an algorithm", "is_correct": False},
            {"text": "Upper bound of algorithm complexity", "is_correct": True},
            {"text": "Lower bound of algorithm complexity", "is_correct": False},
            {"text": "Average case complexity", "is_correct": False},
        ],
    },
    {
        "text": "Which approach is most suitable for solving the 0/1 Knapsack problem optimally?",
        "explanation": "Dynamic programming provides an optimal solution for the 0/1 Knapsack problem by building up solutions for smaller capacities.",
        "reference": "https://en.wikipedia.org/wiki/Knapsack_problem",
        "points": 1,
        "answers": [
            {"text": "Greedy algorithm", "is_correct": False},
            {"text": "Brute force", "is_correct": False},
            {"text": "Dynamic programming", "is_correct": True},
            {"text": "Divide and conquer", "is_correct": False},
        ],
    },
    {
        "text": "What is the time complexity of this TypeScript divide-and-conquer algorithm for maximum subarray sum?\n\n```typescript\nfunction maxSubarrayDC(arr: number[], low: number = 0, high: number = arr.length - 1): number {\n    if (low === high) {\n        return arr[low];\n    }\n    \n    const mid = Math.floor((low + high) / 2);\n    const leftSum = maxSubarrayDC(arr, low, mid);\n    const rightSum = maxSubarrayDC(arr, mid + 1, high);\n    const crossSum = maxCrossingSum(arr, low, mid, high);\n    \n    return Math.max(leftSum, rightSum, crossSum);\n}\n\nfunction maxCrossingSum(arr: number[], low: number, mid: number, high: number): number {\n    let leftSum = -Infinity;\n    let sum = 0;\n    for (let i = mid; i >= low; i--) {\n        sum += arr[i];\n        leftSum = Math.max(leftSum, sum);\n    }\n    \n    let rightSum = -Infinity;\n    sum = 0;\n    for (let i = mid + 1; i <= high; i++) {\n        sum += arr[i];\n        rightSum = Math.max(rightSum, sum);\n    }\n    \n    return leftSum + rightSum;\n}\n```",
        "explanation": "The divide-and-conquer approach for maximum subarray has O(n log n) complexity due to the recursive division and linear crossing sum calculation.",
        "reference": "https://en.wikipedia.org/wiki/Maximum_subarray_problem",
        "points": 3,
        "answers": [
            {"text": "O(n log n)", "is_correct": True},
            {"text": "O(n)", "is_correct": False},
            {"text": "O(n²)", "is_correct": False},
            {"text": "O(log n)", "is_correct": False},
        ],
    },
    {
        "text": "Which algorithm design paradigm best describes the approach used in binary search?",
        "explanation": "Binary search uses divide-and-conquer by repeatedly dividing the search space in half until the target is found or the space is empty.",
        "reference": "https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm",
        "points": 2,
        "answers": [
            {"text": "Divide and conquer", "is_correct": True},
            {"text": "Dynamic programming", "is_correct": False},
            {"text": "Greedy algorithm", "is_correct": False},
            {"text": "Backtracking", "is_correct": False},
        ],
    },
    {
        "text": "What is the recurrence relation for this TypeScript divide-and-conquer matrix multiplication?\n\n```typescript\nfunction matrixMultiplyDC(A: number[][], B: number[][]): number[][] {\n    const n = A.length;\n    if (n === 1) {\n        return [[A[0][0] * B[0][0]]];\n    }\n    \n    const mid = Math.floor(n / 2);\n    \n    // Divide matrices into quadrants\n    const A11 = getSubMatrix(A, 0, 0, mid);\n    const A12 = getSubMatrix(A, 0, mid, mid);\n    const A21 = getSubMatrix(A, mid, 0, mid);\n    const A22 = getSubMatrix(A, mid, mid, mid);\n    \n    const B11 = getSubMatrix(B, 0, 0, mid);\n    const B12 = getSubMatrix(B, 0, mid, mid);\n    const B21 = getSubMatrix(B, mid, 0, mid);\n    const B22 = getSubMatrix(B, mid, mid, mid);\n    \n    // Recursive calls (8 multiplications)\n    const C11 = addMatrices(\n        matrixMultiplyDC(A11, B11),\n        matrixMultiplyDC(A12, B21)\n    );\n    \n    // ... similar for C12, C21, C22\n    \n    return combineMatrices(C11, C12, C21, C22);\n}\n```",
        "explanation": "Standard divide-and-conquer matrix multiplication makes 8 recursive calls on matrices of size n/2, giving T(n) = 8T(n/2) + O(n²).",
        "reference": "https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm",
        "points": 3,
        "answers": [
            {"text": "T(n) = 8T(n/2) + O(n²)", "is_correct": True},
            {"text": "T(n) = 4T(n/2) + O(n²)", "is_correct": False},
            {"text": "T(n) = 2T(n/2) + O(n)", "is_correct": False},
            {"text": "T(n) = 7T(n/2) + O(n²)", "is_correct": False},
        ],
    },
    {
        "text": "Which TypeScript implementation demonstrates the greedy approach for activity selection?\n\n```typescript\ninterface Activity {\n    start: number;\n    finish: number;\n    index: number;\n}\n\nfunction activitySelection(activities: Activity[]): number[] {\n    // Sort by finish time\n    const sorted = [...activities].sort((a, b) => a.finish - b.finish);\n    \n    const selected: number[] = [];\n    let lastFinish = 0;\n    \n    for (const activity of sorted) {\n        if (activity.start >= lastFinish) {\n            selected.push(activity.index);\n            lastFinish = activity.finish;\n        }\n    }\n    \n    return selected;\n}\n```\n\nWhat property makes this greedy choice optimal?",
        "explanation": "The greedy choice of selecting the activity with earliest finish time is optimal because it leaves the most room for subsequent activities.",
        "reference": "https://en.wikipedia.org/wiki/Activity_selection_problem",
        "points": 3,
        "answers": [
            {
                "text": "Earliest finish time leaves most room for future activities",
                "is_correct": True,
            },
            {
                "text": "Shortest duration activities are always optimal",
                "is_correct": False,
            },
            {"text": "Latest start time maximizes utilization", "is_correct": False},
            {"text": "Random selection works equally well", "is_correct": False},
        ],
    },
    {
        "text": "What is the space complexity of this TypeScript dynamic programming solution for Fibonacci?\n\n```typescript\nfunction fibonacciDP(n: number): number {\n    if (n <= 1) return n;\n    \n    const dp = new Array(n + 1);\n    dp[0] = 0;\n    dp[1] = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    \n    return dp[n];\n}\n```",
        "explanation": "This DP solution uses an array of size n+1 to store all Fibonacci values, resulting in O(n) space complexity.",
        "reference": "https://en.wikipedia.org/wiki/Dynamic_programming",
        "points": 2,
        "answers": [
            {"text": "O(n)", "is_correct": True},
            {"text": "O(1)", "is_correct": False},
            {"text": "O(log n)", "is_correct": False},
            {"text": "O(n²)", "is_correct": False},
        ],
    },
    {
        "text": "Which optimization technique is demonstrated in this TypeScript Fibonacci implementation?\n\n```typescript\nfunction fibonacciOptimized(n: number): number {\n    if (n <= 1) return n;\n    \n    let prev2 = 0;\n    let prev1 = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        const current = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    return prev1;\n}\n```",
        "explanation": "This optimization uses space optimization technique, reducing space complexity from O(n) to O(1) by only keeping track of the last two values.",
        "reference": "https://en.wikipedia.org/wiki/Dynamic_programming",
        "points": 2,
        "answers": [
            {"text": "Space optimization", "is_correct": True},
            {"text": "Memoization", "is_correct": False},
            {"text": "Tail recursion", "is_correct": False},
            {"text": "Loop unrolling", "is_correct": False},
        ],
    },
    {
        "text": "What is the Master Theorem solution for T(n) = 4T(n/2) + O(n²)?",
        "explanation": "Using Master Theorem: a=4, b=2, f(n)=n². Since n^(log₂4) = n² = f(n), we're in case 2, so T(n) = O(n² log n).",
        "reference": "https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)",
        "points": 3,
        "answers": [
            {"text": "O(n² log n)", "is_correct": True},
            {"text": "O(n²)", "is_correct": False},
            {"text": "O(n³)", "is_correct": False},
            {"text": "O(n log n)", "is_correct": False},
        ],
    },
    {
        "text": "Which TypeScript implementation correctly demonstrates memoization for optimal substructure?\n\n```typescript\nfunction longestCommonSubsequence(str1: string, str2: string): number {\n    const memo: Map<string, number> = new Map();\n    \n    function lcsHelper(i: number, j: number): number {\n        if (i === str1.length || j === str2.length) {\n            return 0;\n        }\n        \n        const key = `${i},${j}`;\n        if (memo.has(key)) {\n            return memo.get(key)!;\n        }\n        \n        let result: number;\n        if (str1[i] === str2[j]) {\n            result = 1 + lcsHelper(i + 1, j + 1);\n        } else {\n            result = Math.max(\n                lcsHelper(i + 1, j),\n                lcsHelper(i, j + 1)\n            );\n        }\n        \n        memo.set(key, result);\n        return result;\n    }\n    \n    return lcsHelper(0, 0);\n}\n```\n\nWhat is the time complexity of this memoized solution?",
        "explanation": "With memoization, each subproblem (i,j) is solved only once. There are O(mn) subproblems, each taking O(1) time, so total complexity is O(mn).",
        "reference": "https://en.wikipedia.org/wiki/Memoization",
        "points": 3,
        "answers": [
            {"text": "O(mn)", "is_correct": True},
            {"text": "O(2^min(m,n))", "is_correct": False},
            {"text": "O(m + n)", "is_correct": False},
            {"text": "O(m² + n²)", "is_correct": False},
        ],
    },
    {
        "text": "What algorithmic principle is violated in this inefficient TypeScript implementation?\n\n```typescript\nfunction inefficientFibonacci(n: number): number {\n    if (n <= 1) return n;\n    return inefficientFibonacci(n - 1) + inefficientFibonacci(n - 2);\n}\n```",
        "explanation": "This implementation violates the principle of avoiding redundant computation, as it recalculates the same subproblems multiple times without memoization.",
        "reference": "https://en.wikipedia.org/wiki/Overlapping_subproblems",
        "points": 2,
        "answers": [
            {"text": "Avoiding redundant computation", "is_correct": True},
            {"text": "Divide and conquer", "is_correct": False},
            {"text": "Greedy choice property", "is_correct": False},
            {"text": "Optimal substructure", "is_correct": False},
        ],
    },
    {
        "text": "Which amortized analysis technique best explains the average O(1) insertion time in dynamic arrays?\n\n```typescript\nclass DynamicArray<T> {\n    private items: T[] = [];\n    private capacity = 1;\n    private size = 0;\n    \n    insert(item: T): void {\n        if (this.size === this.capacity) {\n            this.resize();\n        }\n        this.items[this.size++] = item;\n    }\n    \n    private resize(): void {\n        const newCapacity = this.capacity * 2;\n        const newItems = new Array(newCapacity);\n        for (let i = 0; i < this.size; i++) {\n            newItems[i] = this.items[i];\n        }\n        this.items = newItems;\n        this.capacity = newCapacity;\n    }\n}\n```",
        "explanation": "The accounting method assigns cost to operations such that expensive operations are 'paid for' by cheaper ones, showing amortized O(1) insertion.",
        "reference": "https://en.wikipedia.org/wiki/Amortized_analysis",
        "points": 3,
        "answers": [
            {"text": "Accounting method", "is_correct": True},
            {"text": "Aggregate analysis", "is_correct": False},
            {"text": "Potential method", "is_correct": False},
            {"text": "Worst-case analysis", "is_correct": False},
        ],
    },
    {
        "text": "What is the optimal substructure property in this TypeScript edit distance implementation?\n\n```typescript\nfunction editDistance(str1: string, str2: string): number {\n    const m = str1.length;\n    const n = str2.length;\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n    \n    // Base cases\n    for (let i = 0; i <= m; i++) dp[i][0] = i;\n    for (let j = 0; j <= n; j++) dp[0][j] = j;\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (str1[i - 1] === str2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + Math.min(\n                    dp[i - 1][j],      // deletion\n                    dp[i][j - 1],      // insertion\n                    dp[i - 1][j - 1]   // substitution\n                );\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n```",
        "explanation": "The optimal substructure means that the optimal solution for the entire problem contains optimal solutions for subproblems (shorter strings).",
        "reference": "https://en.wikipedia.org/wiki/Optimal_substructure",
        "points": 3,
        "answers": [
            {
                "text": "Optimal solution contains optimal solutions to subproblems",
                "is_correct": True,
            },
            {"text": "Subproblems can be solved independently", "is_correct": False},
            {"text": "Greedy choice leads to optimal solution", "is_correct": False},
            {"text": "Problem can be divided into equal parts", "is_correct": False},
        ],
    },
    {
        "text": "Which complexity class does this TypeScript subset sum problem belong to?\n\n```typescript\nfunction subsetSum(nums: number[], target: number): boolean {\n    const n = nums.length;\n    \n    // Try all possible subsets (2^n combinations)\n    for (let mask = 0; mask < (1 << n); mask++) {\n        let sum = 0;\n        for (let i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                sum += nums[i];\n            }\n        }\n        if (sum === target) return True;\n    }\n    \n    return False;\n}\n```",
        "explanation": "This brute force approach tries all 2^n possible subsets, making it an exponential time algorithm, which typically indicates NP-complete problems.",
        "reference": "https://en.wikipedia.org/wiki/Subset_sum_problem",
        "points": 3,
        "answers": [
            {"text": "NP-complete", "is_correct": True},
            {"text": "P", "is_correct": False},
            {"text": "NP-hard but not NP-complete", "is_correct": False},
            {"text": "PSPACE-complete", "is_correct": False},
        ],
    },
    {
        "text": "What optimization principle is applied in this TypeScript matrix chain multiplication?\n\n```typescript\nfunction matrixChainOrder(dimensions: number[]): number {\n    const n = dimensions.length - 1;\n    const dp = Array(n).fill(null).map(() => Array(n).fill(Infinity));\n    \n    // Cost is zero for single matrices\n    for (let i = 0; i < n; i++) {\n        dp[i][i] = 0;\n    }\n    \n    // Fill for chain lengths 2 to n\n    for (let length = 2; length <= n; length++) {\n        for (let i = 0; i <= n - length; i++) {\n            const j = i + length - 1;\n            for (let k = i; k < j; k++) {\n                const cost = dp[i][k] + dp[k + 1][j] + \n                           dimensions[i] * dimensions[k + 1] * dimensions[j + 1];\n                dp[i][j] = Math.min(dp[i][j], cost);\n            }\n        }\n    }\n    \n    return dp[0][n - 1];\n}\n```",
        "explanation": "This applies the principle of optimal substructure where the optimal way to parenthesize a chain of matrices includes optimal parenthesizations of subchains.",
        "reference": "https://en.wikipedia.org/wiki/Matrix_chain_multiplication",
        "points": 3,
        "answers": [
            {"text": "Optimal substructure", "is_correct": True},
            {"text": "Greedy choice property", "is_correct": False},
            {"text": "Overlapping subproblems only", "is_correct": False},
            {"text": "Divide and conquer", "is_correct": False},
        ],
    },
    {
        "text": "What is the lower bound for comparison-based sorting algorithms?",
        "explanation": "Decision tree analysis shows that any comparison-based sorting algorithm must make at least Ω(n log n) comparisons in the worst case.",
        "reference": "https://en.wikipedia.org/wiki/Comparison_sort",
        "points": 2,
        "answers": [
            {"text": "Ω(n log n)", "is_correct": True},
            {"text": "Ω(n)", "is_correct": False},
            {"text": "Ω(n²)", "is_correct": False},
            {"text": "Ω(log n)", "is_correct": False},
        ],
    },
    {
        "text": "Which approximation algorithm characteristic is shown in this TypeScript vertex cover implementation?\n\n```typescript\nfunction approximateVertexCover(edges: [number, number][]): Set<number> {\n    const vertexCover = new Set<number>();\n    const uncoveredEdges = new Set(edges.map(edge => edge.join(',')));\n    \n    while (uncoveredEdges.size > 0) {\n        // Pick any uncovered edge\n        const edgeStr = uncoveredEdges.values().next().value;\n        const [u, v] = edgeStr.split(',').map(Number);\n        \n        // Add both vertices to cover\n        vertexCover.add(u);\n        vertexCover.add(v);\n        \n        // Remove all edges incident to u or v\n        for (const edge of uncoveredEdges) {\n            const [x, y] = edge.split(',').map(Number);\n            if (x === u || x === v || y === u || y === v) {\n                uncoveredEdges.delete(edge);\n            }\n        }\n    }\n    \n    return vertexCover;\n}\n```",
        "explanation": "This is a 2-approximation algorithm because it produces a solution that is at most twice the size of the optimal vertex cover.",
        "reference": "https://en.wikipedia.org/wiki/Vertex_cover",
        "points": 3,
        "answers": [
            {"text": "2-approximation ratio", "is_correct": True},
            {"text": "Optimal solution", "is_correct": False},
            {"text": "Polynomial-time exact algorithm", "is_correct": False},
            {"text": "Exponential approximation ratio", "is_correct": False},
        ],
    },
    {
        "text": "What is the significance of this TypeScript randomized quickselect implementation?\n\n```typescript\nfunction randomizedQuickSelect(arr: number[], k: number): number {\n    const nums = [...arr];\n    \n    function quickSelect(left: number, right: number): number {\n        if (left === right) return nums[left];\n        \n        // Random pivot selection\n        const randomIndex = left + Math.floor(Math.random() * (right - left + 1));\n        [nums[randomIndex], nums[right]] = [nums[right], nums[randomIndex]];\n        \n        const pivotIndex = partition(nums, left, right);\n        \n        if (k === pivotIndex) {\n            return nums[k];\n        } else if (k < pivotIndex) {\n            return quickSelect(left, pivotIndex - 1);\n        } else {\n            return quickSelect(pivotIndex + 1, right);\n        }\n    }\n    \n    return quickSelect(0, nums.length - 1);\n}\n\nfunction partition(arr: number[], left: number, right: number): number {\n    const pivot = arr[right];\n    let i = left;\n    \n    for (let j = left; j < right; j++) {\n        if (arr[j] <= pivot) {\n            [arr[i], arr[j]] = [arr[j], arr[i]];\n            i++;\n        }\n    }\n    \n    [arr[i], arr[right]] = [arr[right], arr[i]];\n    return i;\n}\n```",
        "explanation": "Randomized quickselect has O(n) expected time complexity, avoiding the O(n²) worst case of deterministic quickselect with poor pivot choices.",
        "reference": "https://en.wikipedia.org/wiki/Quickselect",
        "points": 3,
        "answers": [
            {"text": "O(n) expected time complexity", "is_correct": True},
            {"text": "O(n log n) guaranteed complexity", "is_correct": False},
            {"text": "O(log n) space complexity", "is_correct": False},
            {"text": "Deterministic performance", "is_correct": False},
        ],
    },
    {
        "text": "Which design pattern is exemplified by this TypeScript branch and bound implementation?\n\n```typescript\ninterface Node {\n    level: number;\n    profit: number;\n    weight: number;\n    bound: number;\n    items: boolean[];\n}\n\nfunction knapsackBranchBound(weights: number[], values: number[], capacity: number): number {\n    const n = weights.length;\n    const queue: Node[] = [];\n    \n    // Root node\n    const root: Node = {\n        level: -1,\n        profit: 0,\n        weight: 0,\n        bound: calculateBound({level: -1, profit: 0, weight: 0, bound: 0, items: []}, weights, values, capacity),\n        items: new Array(n).fill(False)\n    };\n    \n    queue.push(root);\n    let maxProfit = 0;\n    \n    while (queue.length > 0) {\n        const current = queue.shift()!;\n        \n        if (current.bound > maxProfit && current.level < n - 1) {\n            // Include next item\n            const include: Node = {\n                level: current.level + 1,\n                profit: current.profit + values[current.level + 1],\n                weight: current.weight + weights[current.level + 1],\n                bound: 0,\n                items: [...current.items]\n            };\n            include.items[current.level + 1] = True;\n            \n            if (include.weight <= capacity) {\n                include.bound = calculateBound(include, weights, values, capacity);\n                if (include.bound > maxProfit) {\n                    queue.push(include);\n                }\n                maxProfit = Math.max(maxProfit, include.profit);\n            }\n            \n            // Exclude next item\n            const exclude: Node = {\n                level: current.level + 1,\n                profit: current.profit,\n                weight: current.weight,\n                bound: calculateBound({...current, level: current.level + 1}, weights, values, capacity),\n                items: [...current.items]\n            };\n            \n            if (exclude.bound > maxProfit) {\n                queue.push(exclude);\n            }\n        }\n    }\n    \n    return maxProfit;\n}\n\nfunction calculateBound(node: Node, weights: number[], values: number[], capacity: number): number {\n    if (node.weight >= capacity) return 0;\n    \n    let bound = node.profit;\n    let remainingWeight = capacity - node.weight;\n    \n    for (let i = node.level + 1; i < weights.length && remainingWeight > 0; i++) {\n        if (weights[i] <= remainingWeight) {\n            bound += values[i];\n            remainingWeight -= weights[i];\n        } else {\n            bound += (remainingWeight / weights[i]) * values[i];\n            break;\n        }\n    }\n    \n    return bound;\n}\n```",
        "explanation": "Branch and bound uses systematic enumeration with pruning - it explores the solution space tree but prunes branches that cannot lead to optimal solutions.",
        "reference": "https://en.wikipedia.org/wiki/Branch_and_bound",
        "points": 4,
        "answers": [
            {"text": "Systematic enumeration with pruning", "is_correct": True},
            {"text": "Pure backtracking without optimization", "is_correct": False},
            {"text": "Greedy selection with local optimization", "is_correct": False},
            {"text": "Random sampling of solution space", "is_correct": False},
        ],
    },
    {
        "text": "What algorithmic technique is demonstrated in this TypeScript string matching with preprocessing?\n\n```typescript\nclass KMPMatcher {\n    private pattern: string;\n    private lps: number[];\n    \n    constructor(pattern: string) {\n        this.pattern = pattern;\n        this.lps = this.computeLPS();\n    }\n    \n    private computeLPS(): number[] {\n        const m = this.pattern.length;\n        const lps = new Array(m).fill(0);\n        let len = 0;\n        let i = 1;\n        \n        while (i < m) {\n            if (this.pattern[i] === this.pattern[len]) {\n                len++;\n                lps[i] = len;\n                i++;\n            } else {\n                if (len !== 0) {\n                    len = lps[len - 1];\n                } else {\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n        \n        return lps;\n    }\n    \n    search(text: string): number[] {\n        const n = text.length;\n        const m = this.pattern.length;\n        const matches: number[] = [];\n        let i = 0; // index for text\n        let j = 0; // index for pattern\n        \n        while (i < n) {\n            if (this.pattern[j] === text[i]) {\n                i++;\n                j++;\n            }\n            \n            if (j === m) {\n                matches.push(i - j);\n                j = this.lps[j - 1];\n            } else if (i < n && this.pattern[j] !== text[i]) {\n                if (j !== 0) {\n                    j = this.lps[j - 1];\n                } else {\n                    i++;\n                }\n            }\n        }\n        \n        return matches;\n    }\n}\n```",
        "explanation": "KMP algorithm demonstrates preprocessing optimization - it preprocesses the pattern to avoid redundant comparisons during matching, achieving O(n+m) complexity.",
        "reference": "https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm",
        "points": 3,
        "answers": [
            {"text": "Preprocessing optimization", "is_correct": True},
            {"text": "Dynamic programming", "is_correct": False},
            {"text": "Divide and conquer", "is_correct": False},
            {"text": "Backtracking with memoization", "is_correct": False},
        ],
    },
    {
        "text": "What is the key insight behind this TypeScript linear time selection algorithm?\n\n```typescript\nfunction medianOfMedians(arr: number[], k: number): number {\n    if (arr.length <= 5) {\n        return arr.sort((a, b) => a - b)[k];\n    }\n    \n    // Divide into groups of 5\n    const medians: number[] = [];\n    for (let i = 0; i < arr.length; i += 5) {\n        const group = arr.slice(i, i + 5);\n        group.sort((a, b) => a - b);\n        medians.push(group[Math.floor(group.length / 2)]);\n    }\n    \n    // Find median of medians\n    const medianOfMeds = medianOfMedians(medians, Math.floor(medians.length / 2));\n    \n    // Partition around median of medians\n    const smaller: number[] = [];\n    const equal: number[] = [];\n    const larger: number[] = [];\n    \n    for (const num of arr) {\n        if (num < medianOfMeds) {\n            smaller.push(num);\n        } else if (num === medianOfMeds) {\n            equal.push(num);\n        } else {\n            larger.push(num);\n        }\n    }\n    \n    if (k < smaller.length) {\n        return medianOfMedians(smaller, k);\n    } else if (k < smaller.length + equal.length) {\n        return medianOfMeds;\n    } else {\n        return medianOfMedians(larger, k - smaller.length - equal.length);\n    }\n}\n```",
        "explanation": "The median-of-medians algorithm guarantees a good pivot that eliminates at least 30% of elements, ensuring O(n) worst-case time complexity.",
        "reference": "https://en.wikipedia.org/wiki/Median_of_medians",
        "points": 4,
        "answers": [
            {
                "text": "Guaranteed good pivot selection for linear time",
                "is_correct": True,
            },
            {"text": "Random pivot selection for average case", "is_correct": False},
            {"text": "Sorting small subarrays for efficiency", "is_correct": False},
            {"text": "Divide and conquer with equal partitions", "is_correct": False},
        ],
    },
    {
        "text": "Which property makes this TypeScript greedy algorithm optimal for Huffman coding?\n\n```typescript\nclass HuffmanNode {\n    char?: string;\n    freq: number;\n    left?: HuffmanNode;\n    right?: HuffmanNode;\n    \n    constructor(char: string | undefined, freq: number) {\n        this.char = char;\n        this.freq = freq;\n    }\n}\n\nfunction buildHuffmanTree(frequencies: Map<string, number>): HuffmanNode {\n    const heap: HuffmanNode[] = [];\n    \n    // Create leaf nodes\n    for (const [char, freq] of frequencies) {\n        heap.push(new HuffmanNode(char, freq));\n    }\n    \n    // Build heap (min-heap by frequency)\n    heap.sort((a, b) => a.freq - b.freq);\n    \n    while (heap.length > 1) {\n        // Extract two minimum frequency nodes\n        const left = heap.shift()!;\n        const right = heap.shift()!;\n        \n        // Create internal node\n        const merged = new HuffmanNode(undefined, left.freq + right.freq);\n        merged.left = left;\n        merged.right = right;\n        \n        // Insert back maintaining heap property\n        let i = 0;\n        while (i < heap.length && heap[i].freq < merged.freq) {\n            i++;\n        }\n        heap.splice(i, 0, merged);\n    }\n    \n    return heap[0];\n}\n```",
        "explanation": "The greedy choice of always merging the two lowest frequency nodes is optimal because it minimizes the weighted path length in the resulting tree.",
        "reference": "https://en.wikipedia.org/wiki/Huffman_coding",
        "points": 3,
        "answers": [
            {
                "text": "Merging lowest frequencies minimizes weighted path length",
                "is_correct": True,
            },
            {"text": "Binary tree structure is always optimal", "is_correct": False},
            {
                "text": "Frequent characters get shorter codes by chance",
                "is_correct": False,
            },
            {
                "text": "Left-to-right construction preserves optimality",
                "is_correct": False,
            },
        ],
    },
    {
        "text": "What is the time complexity analysis of this TypeScript union-find with path compression?\n\n```typescript\nclass UnionFind {\n    private parent: number[];\n    private rank: number[];\n    \n    constructor(n: number) {\n        this.parent = Array.from({length: n}, (_, i) => i);\n        this.rank = new Array(n).fill(0);\n    }\n    \n    find(x: number): number {\n        if (this.parent[x] !== x) {\n            // Path compression\n            this.parent[x] = this.find(this.parent[x]);\n        }\n        return this.parent[x];\n    }\n    \n    union(x: number, y: number): boolean {\n        const rootX = this.find(x);\n        const rootY = this.find(y);\n        \n        if (rootX === rootY) return False;\n        \n        // Union by rank\n        if (this.rank[rootX] < this.rank[rootY]) {\n            this.parent[rootX] = rootY;\n        } else if (this.rank[rootX] > this.rank[rootY]) {\n            this.parent[rootY] = rootX;\n        } else {\n            this.parent[rootY] = rootX;\n            this.rank[rootX]++;\n        }\n        \n        return True;\n    }\n}\n```",
        "explanation": "Union-find with path compression and union by rank has O(α(n)) amortized time per operation, where α is the inverse Ackermann function.",
        "reference": "https://en.wikipedia.org/wiki/Disjoint-set_data_structure",
        "points": 3,
        "answers": [
            {"text": "O(α(n)) amortized per operation", "is_correct": True},
            {"text": "O(log n) worst case per operation", "is_correct": False},
            {"text": "O(1) amortized per operation", "is_correct": False},
            {"text": "O(n) worst case per operation", "is_correct": False},
        ],
    },
    {
        "text": "Which computational complexity class does the traveling salesman problem belong to?",
        "explanation": "TSP is NP-hard because every problem in NP can be reduced to it, and it's also NP-complete since we can verify a solution in polynomial time.",
        "reference": "https://en.wikipedia.org/wiki/Travelling_salesman_problem",
        "points": 2,
        "answers": [
            {"text": "NP-complete", "is_correct": True},
            {"text": "P", "is_correct": False},
            {"text": "NP-hard but not in NP", "is_correct": False},
            {"text": "PSPACE-complete", "is_correct": False},
        ],
    },
    {
        "text": "What optimization is achieved by this TypeScript bottom-up dynamic programming approach?\n\n```typescript\nfunction longestIncreasingSubsequence(nums: number[]): number {\n    if (nums.length === 0) return 0;\n    \n    const dp = new Array(nums.length).fill(1);\n    \n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[j] < nums[i]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    \n    return Math.max(...dp);\n}\n```",
        "explanation": "Bottom-up DP avoids the overhead of recursive calls and function call stack, typically providing better constant factors and cache locality.",
        "reference": "https://en.wikipedia.org/wiki/Dynamic_programming",
        "points": 2,
        "answers": [
            {
                "text": "Avoids recursion overhead and improves cache locality",
                "is_correct": True,
            },
            {
                "text": "Reduces time complexity from exponential to polynomial",
                "is_correct": False,
            },
            {"text": "Eliminates the need for memoization", "is_correct": False},
            {"text": "Guarantees optimal space complexity", "is_correct": False},
        ],
    },
    {
        "text": "What is the significance of the choice of hash function in this TypeScript bloom filter implementation?\n\n```typescript\nclass BloomFilter {\n    private bitArray: boolean[];\n    private size: number;\n    private hashCount: number;\n    \n    constructor(size: number, hashCount: number) {\n        this.bitArray = new Array(size).fill(False);\n        this.size = size;\n        this.hashCount = hashCount;\n    }\n    \n    private hash(item: string, seed: number): number {\n        let hash = 0;\n        for (let i = 0; i < item.length; i++) {\n            hash = ((hash << 5) + hash + item.charCodeAt(i) + seed) % this.size;\n        }\n        return Math.abs(hash);\n    }\n    \n    add(item: string): void {\n        for (let i = 0; i < this.hashCount; i++) {\n            const index = this.hash(item, i);\n            this.bitArray[index] = True;\n        }\n    }\n    \n    mightContain(item: string): boolean {\n        for (let i = 0; i < this.hashCount; i++) {\n            const index = this.hash(item, i);\n            if (!this.bitArray[index]) {\n                return False;\n            }\n        }\n        return True;\n    }\n}\n```",
        "explanation": "Good hash functions in bloom filters should be independent and uniformly distributed to minimize False positive rate and ensure even bit distribution.",
        "reference": "https://en.wikipedia.org/wiki/Bloom_filter",
        "points": 3,
        "answers": [
            {
                "text": "Independent and uniform distribution minimizes False positives",
                "is_correct": True,
            },
            {"text": "Cryptographic security prevents attacks", "is_correct": False},
            {"text": "Fast computation is the only requirement", "is_correct": False},
            {"text": "Hash collisions must be completely avoided", "is_correct": False},
        ],
    },
    {
        "text": "Which algorithmic paradigm is demonstrated by this TypeScript backtracking solution?\n\n```typescript\nfunction solveNQueens(n: number): string[][] {\n    const result: string[][] = [];\n    const board: string[][] = Array(n).fill(null).map(() => Array(n).fill('.'));\n    \n    function isValid(row: number, col: number): boolean {\n        // Check column\n        for (let i = 0; i < row; i++) {\n            if (board[i][col] === 'Q') return False;\n        }\n        \n        // Check diagonal\n        for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] === 'Q') return False;\n        }\n        \n        // Check anti-diagonal\n        for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n            if (board[i][j] === 'Q') return False;\n        }\n        \n        return True;\n    }\n    \n    function backtrack(row: number): void {\n        if (row === n) {\n            result.push(board.map(r => r.join('')));\n            return;\n        }\n        \n        for (let col = 0; col < n; col++) {\n            if (isValid(row, col)) {\n                board[row][col] = 'Q';\n                backtrack(row + 1);\n                board[row][col] = '.'; // backtrack\n            }\n        }\n    }\n    \n    backtrack(0);\n    return result;\n}\n```",
        "explanation": "Backtracking explores the solution space systematically and undoes choices when they lead to invalid solutions, finding all feasible solutions.",
        "reference": "https://en.wikipedia.org/wiki/Backtracking",
        "points": 3,
        "answers": [
            {"text": "Systematic exploration with choice reversal", "is_correct": True},
            {"text": "Greedy selection with local optimization", "is_correct": False},
            {"text": "Dynamic programming with memoization", "is_correct": False},
            {
                "text": "Divide and conquer with independent subproblems",
                "is_correct": False,
            },
        ],
    },
    {
        "text": "What is the key principle behind the approximation ratio in this TypeScript set cover greedy algorithm?\n\n```typescript\nfunction greedySetCover(universe: Set<number>, sets: Set<number>[]): number[] {\n    const uncovered = new Set(universe);\n    const selectedSets: number[] = [];\n    \n    while (uncovered.size > 0) {\n        let bestSet = -1;\n        let maxCoverage = 0;\n        \n        // Find set that covers most uncovered elements\n        for (let i = 0; i < sets.length; i++) {\n            const coverage = Array.from(sets[i]).filter(x => uncovered.has(x)).length;\n            if (coverage > maxCoverage) {\n                maxCoverage = coverage;\n                bestSet = i;\n            }\n        }\n        \n        if (bestSet === -1) break;\n        \n        // Add best set and update uncovered elements\n        selectedSets.push(bestSet);\n        for (const element of sets[bestSet]) {\n            uncovered.delete(element);\n        }\n    }\n    \n    return selectedSets;\n}\n```",
        "explanation": "The greedy set cover achieves an H_n approximation ratio (harmonic number) because at each step, the cost per newly covered element is minimized.",
        "reference": "https://en.wikipedia.org/wiki/Set_cover_problem",
        "points": 4,
        "answers": [
            {
                "text": "H_n approximation ratio due to diminishing returns",
                "is_correct": True,
            },
            {
                "text": "2-approximation through careful set selection",
                "is_correct": False,
            },
            {"text": "Optimal solution through greedy choices", "is_correct": False},
            {"text": "Polynomial-time approximation scheme", "is_correct": False},
        ],
    },
]
