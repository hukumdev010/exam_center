"""Data Structures Fundamentals Certification"""

CERTIFICATION = {
    "name": "Data Structures Fundamentals",
    "description": "Core data structures including arrays, linked lists, stacks, queues, trees, and graphs",
    "slug": "data-structures-fundamentals",
    "level": "Associate",
    "duration": 300,
    "questions_count": 100,
    "category_slug": "data-structures-algorithms",
    "is_active": True,
}

QUESTIONS = [{"text": "What is the time complexity of inserting an element at the beginning of a linked list?",
              "explanation": "Inserting at the beginning of a linked list only requires updating the head pointer and the new node's next pointer, which is a constant time operation.",
              "reference": "https://en.wikipedia.org/wiki/Linked_list",
              "points": 1,
              "answers": [{"text": "O(1)",
                           "is_correct": True},
                          {"text": "O(n)",
                           "is_correct": False},
                          {"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n²)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which data structure follows LIFO (Last In, First Out) principle?",
              "explanation": "A stack follows the LIFO principle where the last element added is the first one to be removed.",
              "reference": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)",
              "points": 1,
              "answers": [{"text": "Queue",
                           "is_correct": False},
                          {"text": "Stack",
                           "is_correct": True},
                          {"text": "Array",
                           "is_correct": False},
                          {"text": "Hash Table",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the worst-case time complexity for searching in a binary search tree?",
              "explanation": "In the worst case (when the tree is completely unbalanced), searching in a BST degrades to O(n) where n is the number of nodes.",
              "reference": "https://en.wikipedia.org/wiki/Binary_search_tree",
              "points": 1,
              "answers": [{"text": "O(1)",
                           "is_correct": False},
                          {"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n)",
                           "is_correct": True},
                          {"text": "O(n²)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which operation is NOT typically supported by a stack?",
              "explanation": "Stacks support push, pop, peek/top, and isEmpty operations. Random access to elements at arbitrary positions is not supported.",
              "reference": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)",
              "points": 1,
              "answers": [{"text": "Push",
                           "is_correct": False},
                          {"text": "Pop",
                           "is_correct": False},
                          {"text": "Peek",
                           "is_correct": False},
                          {"text": "Random access",
                           "is_correct": True},
                          ],
              },
             {"text": "What is the time complexity of inserting an element at the end of a dynamic array (like ArrayList)?",
              "explanation": "Inserting at the end of a dynamic array is O(1) amortized time, but O(n) worst case when resizing is needed.",
              "reference": "https://en.wikipedia.org/wiki/Dynamic_array",
              "points": 1,
              "answers": [{"text": "O(1) amortized",
                           "is_correct": True},
                          {"text": "O(n) always",
                           "is_correct": False},
                          {"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n²)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which data structure is best for implementing a priority queue?",
              "explanation": "A heap (binary heap) is the most efficient data structure for implementing a priority queue with O(log n) insert and extract operations.",
              "reference": "https://en.wikipedia.org/wiki/Priority_queue",
              "points": 1,
              "answers": [{"text": "Array",
                           "is_correct": False},
                          {"text": "Linked List",
                           "is_correct": False},
                          {"text": "Heap",
                           "is_correct": True},
                          {"text": "Stack",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the space complexity of a recursive algorithm that makes n recursive calls with each call using O(1) space?",
              "explanation": "Each recursive call adds a frame to the call stack. With n recursive calls, the space complexity is O(n).",
              "reference": "https://en.wikipedia.org/wiki/Call_stack",
              "points": 1,
              "answers": [{"text": "O(1)",
                           "is_correct": False},
                          {"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n)",
                           "is_correct": True},
                          {"text": "O(n²)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which traversal method visits nodes in a binary search tree in sorted order?",
              "explanation": "In-order traversal visits nodes in ascending order for a binary search tree: left subtree, root, right subtree.",
              "reference": "https://en.wikipedia.org/wiki/Tree_traversal",
              "points": 1,
              "answers": [{"text": "Pre-order",
                           "is_correct": False},
                          {"text": "In-order",
                           "is_correct": True},
                          {"text": "Post-order",
                           "is_correct": False},
                          {"text": "Level-order",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the minimum number of nodes in a complete binary tree of height h?",
              "explanation": "A complete binary tree of height h has minimum 2^h nodes (when only the root exists at the last level).",
              "reference": "https://en.wikipedia.org/wiki/Binary_tree",
              "points": 1,
              "answers": [{"text": "h",
                           "is_correct": False},
                          {"text": "2^h - 1",
                           "is_correct": False},
                          {"text": "2^h",
                           "is_correct": True},
                          {"text": "2^(h+1) - 1",
                           "is_correct": False},
                          ],
              },
             {"text": "Which hash collision resolution technique uses a secondary hash function?",
              "explanation": "Double hashing uses a second hash function to determine the step size for probing when a collision occurs.",
              "reference": "https://en.wikipedia.org/wiki/Double_hashing",
              "points": 1,
              "answers": [{"text": "Linear probing",
                           "is_correct": False},
                          {"text": "Quadratic probing",
                           "is_correct": False},
                          {"text": "Double hashing",
                           "is_correct": True},
                          {"text": "Chaining",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the worst-case time complexity for insertion in a hash table with chaining?",
              "explanation": "In the worst case, all elements hash to the same bucket, creating a linked list of length n, making insertion O(n).",
              "reference": "https://en.wikipedia.org/wiki/Hash_table",
              "points": 1,
              "answers": [{"text": "O(1)",
                           "is_correct": False},
                          {"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n)",
                           "is_correct": True},
                          {"text": "O(n²)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which graph representation is more space-efficient for sparse graphs?",
              "explanation": "Adjacency lists use space proportional to the number of vertices plus edges, making them more efficient for sparse graphs.",
              "reference": "https://en.wikipedia.org/wiki/Adjacency_list",
              "points": 1,
              "answers": [{"text": "Adjacency matrix",
                           "is_correct": False},
                          {"text": "Adjacency list",
                           "is_correct": True},
                          {"text": "Edge list",
                           "is_correct": False},
                          {"text": "Incidence matrix",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the time complexity of finding the minimum element in a min-heap?",
              "explanation": "In a min-heap, the minimum element is always at the root, so finding it takes constant time O(1).",
              "reference": "https://en.wikipedia.org/wiki/Binary_heap",
              "points": 1,
              "answers": [{"text": "O(1)",
                           "is_correct": True},
                          {"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n)",
                           "is_correct": False},
                          {"text": "O(n log n)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which data structure is used to implement function calls in programming languages?",
              "explanation": "Function calls are implemented using a call stack, where each function call creates a new frame on the stack.",
              "reference": "https://en.wikipedia.org/wiki/Call_stack",
              "points": 1,
              "answers": [{"text": "Queue",
                           "is_correct": False},
                          {"text": "Stack",
                           "is_correct": True},
                          {"text": "Heap",
                           "is_correct": False},
                          {"text": "Hash table",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the maximum number of children a node can have in a binary tree?",
              "explanation": "By definition, a binary tree node can have at most 2 children: left child and right child.",
              "reference": "https://en.wikipedia.org/wiki/Binary_tree",
              "points": 1,
              "answers": [{"text": "1",
                           "is_correct": False},
                          {"text": "2",
                           "is_correct": True},
                          {"text": "3",
                           "is_correct": False},
                          {"text": "Unlimited",
                           "is_correct": False},
                          ],
              },
             {"text": "Which sorting algorithm has the best worst-case time complexity?",
              "explanation": "Merge sort has O(n log n) worst-case time complexity, which is optimal for comparison-based sorting algorithms.",
              "reference": "https://en.wikipedia.org/wiki/Merge_sort",
              "points": 1,
              "answers": [{"text": "Quick sort",
                           "is_correct": False},
                          {"text": "Bubble sort",
                           "is_correct": False},
                          {"text": "Merge sort",
                           "is_correct": True},
                          {"text": "Selection sort",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the space complexity of an iterative binary search?",
              "explanation": "Iterative binary search uses only a constant amount of additional space for variables like low, high, and mid.",
              "reference": "https://en.wikipedia.org/wiki/Binary_search_algorithm",
              "points": 1,
              "answers": [{"text": "O(1)",
                           "is_correct": True},
                          {"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n)",
                           "is_correct": False},
                          {"text": "O(n log n)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which data structure would be most efficient for implementing an LRU (Least Recently Used) cache?",
              "explanation": "A combination of hash table and doubly linked list provides O(1) access, insertion, and deletion for LRU cache operations.",
              "reference": "https://en.wikipedia.org/wiki/Cache_replacement_policies",
              "points": 1,
              "answers": [{"text": "Array only",
                           "is_correct": False},
                          {"text": "Hash table only",
                           "is_correct": False},
                          {"text": "Hash table + Doubly linked list",
                           "is_correct": True},
                          {"text": "Binary search tree",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the time complexity of deleting an element from the middle of an array?",
              "explanation": "Deleting from the middle requires shifting all subsequent elements one position left, resulting in O(n) time complexity.",
              "reference": "https://en.wikipedia.org/wiki/Array_data_structure",
              "points": 1,
              "answers": [{"text": "O(1)",
                           "is_correct": False},
                          {"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n)",
                           "is_correct": True},
                          {"text": "O(n²)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which tree property ensures that the height is always O(log n)?",
              "explanation": "A balanced tree maintains the property that the height difference between left and right subtrees is at most 1, ensuring O(log n) height.",
              "reference": "https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree",
              "points": 1,
              "answers": [{"text": "Complete",
                           "is_correct": False},
                          {"text": "Full",
                           "is_correct": False},
                          {"text": "Balanced",
                           "is_correct": True},
                          {"text": "Perfect",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the primary advantage of a circular queue over a linear queue?",
              "explanation": "Circular queues efficiently reuse space by wrapping around to the beginning when the end is reached, avoiding wasted space.",
              "reference": "https://en.wikipedia.org/wiki/Circular_buffer",
              "points": 1,
              "answers": [{"text": "Faster operations",
                           "is_correct": False},
                          {"text": "Space reuse",
                           "is_correct": True},
                          {"text": "Simpler implementation",
                           "is_correct": False},
                          {"text": "Better memory locality",
                           "is_correct": False},
                          ],
              },
             {"text": "Which graph algorithm is used to find the shortest path in an unweighted graph?",
              "explanation": "BFS (Breadth-First Search) finds the shortest path in terms of number of edges in an unweighted graph.",
              "reference": "https://en.wikipedia.org/wiki/Breadth-first_search",
              "points": 1,
              "answers": [{"text": "DFS",
                           "is_correct": False},
                          {"text": "BFS",
                           "is_correct": True},
                          {"text": "Dijkstra's",
                           "is_correct": False},
                          {"text": "A*",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the time complexity of building a heap from an unsorted array?",
              "explanation": "Building a heap from an unsorted array using the heapify process takes O(n) time, not O(n log n).",
              "reference": "https://en.wikipedia.org/wiki/Binary_heap",
              "points": 1,
              "answers": [{"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n)",
                           "is_correct": True},
                          {"text": "O(n log n)",
                           "is_correct": False},
                          {"text": "O(n²)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which data structure is most suitable for implementing a symbol table in a compiler?",
              "explanation": "Hash tables provide O(1) average-case lookup, insertion, and deletion, making them ideal for symbol tables.",
              "reference": "https://en.wikipedia.org/wiki/Symbol_table",
              "points": 1,
              "answers": [{"text": "Array",
                           "is_correct": False},
                          {"text": "Linked list",
                           "is_correct": False},
                          {"text": "Hash table",
                           "is_correct": True},
                          {"text": "Stack",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the maximum number of nodes at level k in a binary tree?",
              "explanation": "At level k (0-indexed), a binary tree can have at most 2^k nodes.",
              "reference": "https://en.wikipedia.org/wiki/Binary_tree",
              "points": 1,
              "answers": [{"text": "k",
                           "is_correct": False},
                          {"text": "2k",
                           "is_correct": False},
                          {"text": "2^k",
                           "is_correct": True},
                          {"text": "k²",
                           "is_correct": False},
                          ],
              },
             {"text": "Which operation is most expensive in a singly linked list?",
              "explanation": "Finding the last node in a singly linked list requires traversing the entire list, taking O(n) time.",
              "reference": "https://en.wikipedia.org/wiki/Linked_list",
              "points": 1,
              "answers": [{"text": "Insert at beginning",
                           "is_correct": False},
                          {"text": "Delete first node",
                           "is_correct": False},
                          {"text": "Find last node",
                           "is_correct": True},
                          {"text": "Insert after given node",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the load factor in a hash table?",
              "explanation": "Load factor is the ratio of the number of stored elements to the total number of slots in the hash table.",
              "reference": "https://en.wikipedia.org/wiki/Hash_table",
              "points": 1,
              "answers": [{"text": "Number of collisions",
                           "is_correct": False},
                          {"text": "Number of elements / Table size",
                           "is_correct": True},
                          {"text": "Number of empty slots",
                           "is_correct": False},
                          {"text": "Average probe distance",
                           "is_correct": False},
                          ],
              },
             {"text": "Which tree traversal method is used in expression evaluation?",
              "explanation": "Post-order traversal is used for evaluating mathematical expressions represented as binary trees.",
              "reference": "https://en.wikipedia.org/wiki/Tree_traversal",
              "points": 1,
              "answers": [{"text": "Pre-order",
                           "is_correct": False},
                          {"text": "In-order",
                           "is_correct": False},
                          {"text": "Post-order",
                           "is_correct": True},
                          {"text": "Level-order",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the time complexity of finding the kth smallest element in an unsorted array using a heap?",
              "explanation": "Using a min-heap, we can find the kth smallest element in O(n + k log n) time by building the heap and extracting k elements.",
              "reference": "https://en.wikipedia.org/wiki/Selection_algorithm",
              "points": 1,
              "answers": [{"text": "O(k)",
                           "is_correct": False},
                          {"text": "O(n + k log n)",
                           "is_correct": True},
                          {"text": "O(n log n)",
                           "is_correct": False},
                          {"text": "O(kn)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which data structure uses the concept of 'buckets'?",
              "explanation": "Hash tables use buckets to store elements that hash to the same index, especially in collision resolution strategies.",
              "reference": "https://en.wikipedia.org/wiki/Hash_table",
              "points": 1,
              "answers": [{"text": "Stack",
                           "is_correct": False},
                          {"text": "Queue",
                           "is_correct": False},
                          {"text": "Hash table",
                           "is_correct": True},
                          {"text": "Binary tree",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the minimum height of a binary tree with n nodes?",
              "explanation": "The minimum height of a binary tree with n nodes is floor(log₂(n)), achieved in a complete binary tree.",
              "reference": "https://en.wikipedia.org/wiki/Binary_tree",
              "points": 1,
              "answers": [{"text": "log₂(n)",
                           "is_correct": True},
                          {"text": "n",
                           "is_correct": False},
                          {"text": "√n",
                           "is_correct": False},
                          {"text": "n/2",
                           "is_correct": False},
                          ],
              },
             {"text": "Which graph representation allows fastest edge existence checking?",
              "explanation": "Adjacency matrix allows O(1) time to check if an edge exists between two vertices.",
              "reference": "https://en.wikipedia.org/wiki/Adjacency_matrix",
              "points": 1,
              "answers": [{"text": "Adjacency list",
                           "is_correct": False},
                          {"text": "Adjacency matrix",
                           "is_correct": True},
                          {"text": "Edge list",
                           "is_correct": False},
                          {"text": "Incidence matrix",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the space complexity of storing a complete binary tree in an array?",
              "explanation": "A complete binary tree with n nodes can be stored in an array of size n with no wasted space, so space complexity is O(n).",
              "reference": "https://en.wikipedia.org/wiki/Binary_heap",
              "points": 1,
              "answers": [{"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n)",
                           "is_correct": True},
                          {"text": "O(n log n)",
                           "is_correct": False},
                          {"text": "O(2ⁿ)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which operation in a double-ended queue (deque) takes O(1) time?",
              "explanation": "Deques support O(1) insertion and deletion at both ends, making them efficient for various algorithms.",
              "reference": "https://en.wikipedia.org/wiki/Double-ended_queue",
              "points": 1,
              "answers": [{"text": "Insert at middle",
                           "is_correct": False},
                          {"text": "Insert at front",
                           "is_correct": True},
                          {"text": "Search",
                           "is_correct": False},
                          {"text": "Sort",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the advantage of using a balanced binary search tree over an unbalanced one?",
              "explanation": "Balanced BSTs guarantee O(log n) height, ensuring efficient O(log n) search, insertion, and deletion operations.",
              "reference": "https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree",
              "points": 1,
              "answers": [{"text": "Uses less memory",
                           "is_correct": False},
                          {"text": "Guarantees O(log n) operations",
                           "is_correct": True},
                          {"text": "Simpler to implement",
                           "is_correct": False},
                          {"text": "Supports more operations",
                           "is_correct": False},
                          ],
              },
             {"text": "Which data structure is best for implementing undo operations in a text editor?",
              "explanation": "A stack is perfect for undo operations as it naturally supports LIFO behavior - the last action is the first to be undone.",
              "reference": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)",
              "points": 1,
              "answers": [{"text": "Queue",
                           "is_correct": False},
                          {"text": "Stack",
                           "is_correct": True},
                          {"text": "Hash table",
                           "is_correct": False},
                          {"text": "Binary tree",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the time complexity of merging two sorted arrays of sizes m and n?",
              "explanation": "Merging two sorted arrays requires examining each element once, resulting in O(m + n) time complexity.",
              "reference": "https://en.wikipedia.org/wiki/Merge_algorithm",
              "points": 1,
              "answers": [{"text": "O(m + n)",
                           "is_correct": True},
                          {"text": "O(m × n)",
                           "is_correct": False},
                          {"text": "O(log(m + n))",
                           "is_correct": False},
                          {"text": "O(max(m, n))",
                           "is_correct": False},
                          ],
              },
             {"text": "Which property must be satisfied for a binary tree to be a valid binary search tree?",
              "explanation": "In a BST, for every node, all values in the left subtree must be less than the node's value, and all values in the right subtree must be greater.",
              "reference": "https://en.wikipedia.org/wiki/Binary_search_tree",
              "points": 1,
              "answers": [{"text": "All nodes have exactly two children",
                           "is_correct": False},
                          {"text": "Left < Node < Right for all nodes",
                           "is_correct": True},
                          {"text": "Tree must be complete",
                           "is_correct": False},
                          {"text": "All leaves are at the same level",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the worst-case time complexity of quicksort?",
              "explanation": "Quicksort has O(n²) worst-case time complexity when the pivot is always the smallest or largest element.",
              "reference": "https://en.wikipedia.org/wiki/Quicksort",
              "points": 1,
              "answers": [{"text": "O(n log n)",
                           "is_correct": False},
                          {"text": "O(n²)",
                           "is_correct": True},
                          {"text": "O(n)",
                           "is_correct": False},
                          {"text": "O(log n)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which data structure is most efficient for range queries on an array?",
              "explanation": "Segment trees provide O(log n) time complexity for both range queries and updates on arrays.",
              "reference": "https://en.wikipedia.org/wiki/Segment_tree",
              "points": 1,
              "answers": [{"text": "Array",
                           "is_correct": False},
                          {"text": "Hash table",
                           "is_correct": False},
                          {"text": "Segment tree",
                           "is_correct": True},
                          {"text": "Linked list",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the time complexity of checking if a graph is connected using DFS?",
              "explanation": "DFS visits each vertex and edge once to check connectivity, resulting in O(V + E) time complexity.",
              "reference": "https://en.wikipedia.org/wiki/Depth-first_search",
              "points": 1,
              "answers": [{"text": "O(V)",
                           "is_correct": False},
                          {"text": "O(E)",
                           "is_correct": False},
                          {"text": "O(V + E)",
                           "is_correct": True},
                          {"text": "O(V × E)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which hash function property helps minimize collisions?",
              "explanation": "Uniform distribution ensures that hash values are spread evenly across the hash table, minimizing clustering and collisions.",
              "reference": "https://en.wikipedia.org/wiki/Hash_function",
              "points": 1,
              "answers": [{"text": "Deterministic",
                           "is_correct": False},
                          {"text": "Fast computation",
                           "is_correct": False},
                          {"text": "Uniform distribution",
                           "is_correct": True},
                          {"text": "Reversible",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the main disadvantage of using arrays for implementing stacks?",
              "explanation": "Arrays have fixed size, which can lead to stack overflow if the stack grows beyond the array size, or memory waste if the stack is small.",
              "reference": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)",
              "points": 1,
              "answers": [{"text": "Slow operations",
                           "is_correct": False},
                          {"text": "Fixed size",
                           "is_correct": True},
                          {"text": "Complex implementation",
                           "is_correct": False},
                          {"text": "Poor memory locality",
                           "is_correct": False},
                          ],
              },
             {"text": "Which algorithm is used to topologically sort a directed acyclic graph (DAG)?",
              "explanation": "Kahn's algorithm uses BFS with in-degree counting to produce a topological ordering of a DAG.",
              "reference": "https://en.wikipedia.org/wiki/Topological_sorting",
              "points": 1,
              "answers": [{"text": "Dijkstra's algorithm",
                           "is_correct": False},
                          {"text": "Kahn's algorithm",
                           "is_correct": True},
                          {"text": "Floyd-Warshall",
                           "is_correct": False},
                          {"text": "Prim's algorithm",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the time complexity of inserting n elements into an empty binary search tree in the worst case?",
              "explanation": "In the worst case (sorted input), the BST becomes a linear chain, and inserting n elements takes O(n²) time.",
              "reference": "https://en.wikipedia.org/wiki/Binary_search_tree",
              "points": 1,
              "answers": [{"text": "O(n)",
                           "is_correct": False},
                          {"text": "O(n log n)",
                           "is_correct": False},
                          {"text": "O(n²)",
                           "is_correct": True},
                          {"text": "O(2ⁿ)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which data structure provides the best average-case performance for dictionary operations?",
              "explanation": "Hash tables provide O(1) average-case time complexity for insert, delete, and search operations.",
              "reference": "https://en.wikipedia.org/wiki/Hash_table",
              "points": 1,
              "answers": [{"text": "Binary search tree",
                           "is_correct": False},
                          {"text": "Hash table",
                           "is_correct": True},
                          {"text": "Array",
                           "is_correct": False},
                          {"text": "Linked list",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the maximum number of edges in a simple directed graph with n vertices?",
              "explanation": "In a simple directed graph, each vertex can have an edge to every other vertex, giving n(n-1) maximum edges.",
              "reference": "https://en.wikipedia.org/wiki/Directed_graph",
              "points": 1,
              "answers": [{"text": "n",
                           "is_correct": False},
                          {"text": "n-1",
                           "is_correct": False},
                          {"text": "n(n-1)/2",
                           "is_correct": False},
                          {"text": "n(n-1)",
                           "is_correct": True},
                          ],
              },
             {"text": "Which traversal technique is used in breadth-first search?",
              "explanation": "BFS uses a queue data structure to visit nodes level by level in breadth-first order.",
              "reference": "https://en.wikipedia.org/wiki/Breadth-first_search",
              "points": 1,
              "answers": [{"text": "Stack-based",
                           "is_correct": False},
                          {"text": "Queue-based",
                           "is_correct": True},
                          {"text": "Recursive",
                           "is_correct": False},
                          {"text": "Priority queue-based",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the space complexity of the recursive implementation of factorial?",
              "explanation": "Recursive factorial makes n recursive calls, each using O(1) space, resulting in O(n) space complexity due to the call stack.",
              "reference": "https://en.wikipedia.org/wiki/Recursion_(computer_science)",
              "points": 1,
              "answers": [{"text": "O(1)",
                           "is_correct": False},
                          {"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n)",
                           "is_correct": True},
                          {"text": "O(n²)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which operation is NOT supported efficiently by a min-heap?",
              "explanation": "Searching for an arbitrary element in a heap takes O(n) time since heaps are not designed for searching.",
              "reference": "https://en.wikipedia.org/wiki/Binary_heap",
              "points": 1,
              "answers": [{"text": "Insert",
                           "is_correct": False},
                          {"text": "Extract minimum",
                           "is_correct": False},
                          {"text": "Find minimum",
                           "is_correct": False},
                          {"text": "Search arbitrary element",
                           "is_correct": True},
                          ],
              },
             {"text": "What is the key advantage of using a doubly linked list over a singly linked list?",
              "explanation": "Doubly linked lists allow traversal in both directions and enable O(1) deletion when given a pointer to the node.",
              "reference": "https://en.wikipedia.org/wiki/Doubly_linked_list",
              "points": 1,
              "answers": [{"text": "Uses less memory",
                           "is_correct": False},
                          {"text": "Bidirectional traversal",
                           "is_correct": True},
                          {"text": "Faster search",
                           "is_correct": False},
                          {"text": "Simpler implementation",
                           "is_correct": False},
                          ],
              },
             {"text": "Which sorting algorithm is stable and has O(n log n) worst-case time complexity?",
              "explanation": "Merge sort is stable (maintains relative order of equal elements) and has O(n log n) time complexity in all cases.",
              "reference": "https://en.wikipedia.org/wiki/Merge_sort",
              "points": 1,
              "answers": [{"text": "Quick sort",
                           "is_correct": False},
                          {"text": "Heap sort",
                           "is_correct": False},
                          {"text": "Merge sort",
                           "is_correct": True},
                          {"text": "Selection sort",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the time complexity of finding the diameter of a binary tree?",
              "explanation": "Finding the diameter requires visiting each node once to compute the height of subtrees, resulting in O(n) time complexity.",
              "reference": "https://en.wikipedia.org/wiki/Tree_(data_structure)",
              "points": 1,
              "answers": [{"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n)",
                           "is_correct": True},
                          {"text": "O(n log n)",
                           "is_correct": False},
                          {"text": "O(n²)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which data structure is best for implementing a web browser's back button functionality?",
              "explanation": "A stack naturally implements the back button functionality where the most recent page is the first to be returned to.",
              "reference": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)",
              "points": 1,
              "answers": [{"text": "Queue",
                           "is_correct": False},
                          {"text": "Stack",
                           "is_correct": True},
                          {"text": "Hash table",
                           "is_correct": False},
                          {"text": "Binary tree",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the minimum number of comparisons needed to find both maximum and minimum elements in an array of n elements?",
              "explanation": "By comparing elements in pairs and then comparing winners for max and losers for min, we need 3n/2 - 2 comparisons.",
              "reference": "https://en.wikipedia.org/wiki/Selection_algorithm",
              "points": 1,
              "answers": [{"text": "n",
                           "is_correct": False},
                          {"text": "2n - 2",
                           "is_correct": False},
                          {"text": "3n/2 - 2",
                           "is_correct": True},
                          {"text": "n log n",
                           "is_correct": False},
                          ],
              },
             {"text": "Which collision resolution technique in hashing can lead to clustering?",
              "explanation": "Linear probing can cause primary clustering where consecutive hash table slots become occupied, leading to longer probe sequences.",
              "reference": "https://en.wikipedia.org/wiki/Linear_probing",
              "points": 1,
              "answers": [{"text": "Chaining",
                           "is_correct": False},
                          {"text": "Linear probing",
                           "is_correct": True},
                          {"text": "Double hashing",
                           "is_correct": False},
                          {"text": "Cuckoo hashing",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the space complexity of an adjacency matrix representation of a graph with V vertices?",
              "explanation": "An adjacency matrix requires V × V space to store the presence/absence of edges between all pairs of vertices.",
              "reference": "https://en.wikipedia.org/wiki/Adjacency_matrix",
              "points": 1,
              "answers": [{"text": "O(V)",
                           "is_correct": False},
                          {"text": "O(V²)",
                           "is_correct": True},
                          {"text": "O(E)",
                           "is_correct": False},
                          {"text": "O(V + E)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which tree rotation operation is used in AVL tree balancing?",
              "explanation": "AVL trees use left and right rotations (and their combinations) to maintain balance after insertions and deletions.",
              "reference": "https://en.wikipedia.org/wiki/AVL_tree",
              "points": 1,
              "answers": [{"text": "Splitting",
                           "is_correct": False},
                          {"text": "Rotation",
                           "is_correct": True},
                          {"text": "Merging",
                           "is_correct": False},
                          {"text": "Swapping",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the average-case time complexity of quicksort?",
              "explanation": "Quicksort has O(n log n) average-case time complexity when the pivot divides the array roughly in half.",
              "reference": "https://en.wikipedia.org/wiki/Quicksort",
              "points": 1,
              "answers": [{"text": "O(n)",
                           "is_correct": False},
                          {"text": "O(n log n)",
                           "is_correct": True},
                          {"text": "O(n²)",
                           "is_correct": False},
                          {"text": "O(log n)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which data structure is used to implement breadth-first search?",
              "explanation": "BFS uses a queue to process vertices in the order they are discovered, ensuring breadth-first exploration.",
              "reference": "https://en.wikipedia.org/wiki/Breadth-first_search",
              "points": 1,
              "answers": [{"text": "Stack",
                           "is_correct": False},
                          {"text": "Queue",
                           "is_correct": True},
                          {"text": "Heap",
                           "is_correct": False},
                          {"text": "Hash table",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the height of a complete binary tree with n nodes?",
              "explanation": "The height of a complete binary tree with n nodes is floor(log₂(n)), as it fills levels from left to right.",
              "reference": "https://en.wikipedia.org/wiki/Binary_tree",
              "points": 1,
              "answers": [{"text": "n",
                           "is_correct": False},
                          {"text": "log₂(n)",
                           "is_correct": True},
                          {"text": "√n",
                           "is_correct": False},
                          {"text": "n/2",
                           "is_correct": False},
                          ],
              },
             {"text": "Which operation in a trie (prefix tree) takes O(m) time where m is the length of the string?",
              "explanation": "All basic trie operations (insert, search, delete) take O(m) time where m is the length of the string being processed.",
              "reference": "https://en.wikipedia.org/wiki/Trie",
              "points": 1,
              "answers": [{"text": "Insert only",
                           "is_correct": False},
                          {"text": "Search only",
                           "is_correct": False},
                          {"text": "All operations",
                           "is_correct": True},
                          {"text": "Delete only",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the maximum number of nodes in a binary tree of height h?",
              "explanation": "A complete binary tree of height h has maximum 2^(h+1) - 1 nodes when all levels are completely filled.",
              "reference": "https://en.wikipedia.org/wiki/Binary_tree",
              "points": 1,
              "answers": [{"text": "h",
                           "is_correct": False},
                          {"text": "2^h",
                           "is_correct": False},
                          {"text": "2^(h+1) - 1",
                           "is_correct": True},
                          {"text": "2h + 1",
                           "is_correct": False},
                          ],
              },
             {"text": "Which graph algorithm can detect cycles in a directed graph?",
              "explanation": "DFS can detect cycles in a directed graph by tracking vertices in the current recursion stack (back edges indicate cycles).",
              "reference": "https://en.wikipedia.org/wiki/Cycle_(graph_theory)",
              "points": 1,
              "answers": [{"text": "BFS only",
                           "is_correct": False},
                          {"text": "DFS",
                           "is_correct": True},
                          {"text": "Dijkstra's algorithm",
                           "is_correct": False},
                          {"text": "Kruskal's algorithm",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the time complexity of checking if two binary trees are identical?",
              "explanation": "Checking if two binary trees are identical requires visiting each node in both trees once, resulting in O(n) time complexity.",
              "reference": "https://en.wikipedia.org/wiki/Binary_tree",
              "points": 1,
              "answers": [{"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n)",
                           "is_correct": True},
                          {"text": "O(n log n)",
                           "is_correct": False},
                          {"text": "O(n²)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which data structure allows efficient insertion and deletion at both ends?",
              "explanation": "A deque (double-ended queue) supports O(1) insertion and deletion at both the front and rear ends.",
              "reference": "https://en.wikipedia.org/wiki/Double-ended_queue",
              "points": 1,
              "answers": [{"text": "Stack",
                           "is_correct": False},
                          {"text": "Queue",
                           "is_correct": False},
                          {"text": "Deque",
                           "is_correct": True},
                          {"text": "Array",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the worst-case space complexity of merge sort?",
              "explanation": "Merge sort requires O(n) auxiliary space for the temporary arrays used during the merging process.",
              "reference": "https://en.wikipedia.org/wiki/Merge_sort",
              "points": 1,
              "answers": [{"text": "O(1)",
                           "is_correct": False},
                          {"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n)",
                           "is_correct": True},
                          {"text": "O(n log n)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which property distinguishes a red-black tree from other binary search trees?",
              "explanation": "Red-black trees use color coding (red and black) with specific rules to maintain balance and ensure O(log n) operations.",
              "reference": "https://en.wikipedia.org/wiki/Red%E2%80%93black_tree",
              "points": 1,
              "answers": [{"text": "Node values",
                           "is_correct": False},
                          {"text": "Node colors",
                           "is_correct": True},
                          {"text": "Node weights",
                           "is_correct": False},
                          {"text": "Node priorities",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the time complexity of deleting a node from a binary search tree?",
              "explanation": "Deleting a node from a BST involves finding the node and possibly rearranging the tree, taking O(h) time where h is the height.",
              "reference": "https://en.wikipedia.org/wiki/Binary_search_tree",
              "points": 1,
              "answers": [{"text": "O(1)",
                           "is_correct": False},
                          {"text": "O(log n) average",
                           "is_correct": True},
                          {"text": "O(n) always",
                           "is_correct": False},
                          {"text": "O(n²)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which sorting algorithm performs best on nearly sorted arrays?",
              "explanation": "Insertion sort performs very well on nearly sorted arrays, with time complexity approaching O(n) for sorted input.",
              "reference": "https://en.wikipedia.org/wiki/Insertion_sort",
              "points": 1,
              "answers": [{"text": "Quick sort",
                           "is_correct": False},
                          {"text": "Merge sort",
                           "is_correct": False},
                          {"text": "Insertion sort",
                           "is_correct": True},
                          {"text": "Heap sort",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the primary advantage of using a hash table over a sorted array for dictionary operations?",
              "explanation": "Hash tables provide O(1) average-case time for insert, delete, and search, while sorted arrays require O(log n) for search and O(n) for modifications.",
              "reference": "https://en.wikipedia.org/wiki/Hash_table",
              "points": 1,
              "answers": [{"text": "Less memory usage",
                           "is_correct": False},
                          {"text": "Faster average operations",
                           "is_correct": True},
                          {"text": "Maintains sorted order",
                           "is_correct": False},
                          {"text": "Better cache locality",
                           "is_correct": False},
                          ],
              },
             {"text": "Which tree traversal method produces a sorted sequence for a binary search tree?",
              "explanation": "In-order traversal of a BST visits nodes in ascending order: left subtree, root, right subtree.",
              "reference": "https://en.wikipedia.org/wiki/Tree_traversal",
              "points": 1,
              "answers": [{"text": "Pre-order",
                           "is_correct": False},
                          {"text": "In-order",
                           "is_correct": True},
                          {"text": "Post-order",
                           "is_correct": False},
                          {"text": "Level-order",
                           "is_correct": False},
                          ],
              },
             {"text": "What will be the output of this TypeScript stack implementation?\n\n```typescript\nclass Stack<T> {\n  private items: T[] = [];\n  \n  push(item: T): void {\n    this.items.push(item);\n  }\n  \n  pop(): T | undefined {\n    return this.items.pop();\n  }\n}\n\nconst stack = new Stack<number>();\nstack.push(1);\nstack.push(2);\nstack.push(3);\nconsole.log(stack.pop());\nconsole.log(stack.pop());\n```",
              "explanation": "The stack follows LIFO principle. After pushing 1, 2, 3, the first pop() returns 3 (last pushed), and the second pop() returns 2.",
              "reference": "https://www.typescriptlang.org/docs/handbook/2/generics.html",
              "points": 2,
              "answers": [{"text": "3, 2",
                           "is_correct": True},
                          {"text": "1, 2",
                           "is_correct": False},
                          {"text": "2, 3",
                           "is_correct": False},
                          {"text": "1, 3",
                           "is_correct": False},
                          ],
              },
             {"text": "Which TypeScript interface correctly defines a binary tree node?",
              "explanation": "A binary tree node needs a value and optional left and right child references. Using generics allows for different data types.",
              "reference": "https://www.typescriptlang.org/docs/handbook/2/objects.html",
              "points": 2,
              "answers": [{"text": "interface TreeNode<T> { value: T; left?: TreeNode<T>; right?: TreeNode<T>; }",
                           "is_correct": True,
                           },
                          {"text": "interface TreeNode { value: any; left: TreeNode; right: TreeNode; }",
                           "is_correct": False,
                           },
                          {"text": "interface TreeNode<T> { data: T; children: TreeNode<T>[]; }",
                           "is_correct": False,
                           },
                          {"text": "interface TreeNode<T> { value: T; parent: TreeNode<T>; }",
                           "is_correct": False,
                           },
                          ],
              },
             {"text": "What is the time complexity of this TypeScript linked list insertion method?\n\n```typescript\nclass ListNode<T> {\n  constructor(public value: T, public next?: ListNode<T>) {}\n}\n\nclass LinkedList<T> {\n  private head?: ListNode<T>;\n  \n  insertAtBeginning(value: T): void {\n    const newNode = new ListNode(value, this.head);\n    this.head = newNode;\n  }\n}\n```",
              "explanation": "Inserting at the beginning only requires creating a new node and updating the head pointer, which takes constant time.",
              "reference": "https://en.wikipedia.org/wiki/Linked_list",
              "points": 2,
              "answers": [{"text": "O(1)",
                           "is_correct": True},
                          {"text": "O(n)",
                           "is_correct": False},
                          {"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n²)",
                           "is_correct": False},
                          ],
              },
             {"text": "What will this TypeScript queue implementation output?\n\n```typescript\nclass Queue<T> {\n  private items: T[] = [];\n  \n  enqueue(item: T): void {\n    this.items.push(item);\n  }\n  \n  dequeue(): T | undefined {\n    return this.items.shift();\n  }\n}\n\nconst queue = new Queue<string>();\nqueue.enqueue('A');\nqueue.enqueue('B');\nqueue.enqueue('C');\nconsole.log(queue.dequeue());\nconsole.log(queue.dequeue());\n```",
              "explanation": "Queue follows FIFO principle. 'A' was enqueued first, so it's dequeued first, followed by 'B'.",
              "reference": "https://en.wikipedia.org/wiki/Queue_(abstract_data_type)",
              "points": 2,
              "answers": [{"text": "A, B",
                           "is_correct": True},
                          {"text": "C, B",
                           "is_correct": False},
                          {"text": "B, A",
                           "is_correct": False},
                          {"text": "A, C",
                           "is_correct": False},
                          ],
              },
             {"text": "Which TypeScript hash map implementation has the best time complexity for get operations?",
              "explanation": "Using Map provides O(1) average time complexity for get operations, while object property access can be slower in some cases.",
              "reference": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
              "points": 2,
              "answers": [{"text": "class HashMap<K, V> { private map = new Map<K, V>(); }",
                           "is_correct": True,
                           },
                          {"text": "class HashMap<K, V> { private obj: Record<string, V> = {}; }",
                           "is_correct": False,
                           },
                          {"text": "class HashMap<K, V> { private arr: [K, V][] = []; }",
                           "is_correct": False,
                           },
                          {"text": "class HashMap<K, V> { private set = new Set<[K, V]>(); }",
                           "is_correct": False,
                           },
                          ],
              },
             {"text": "What is the output of this TypeScript binary search implementation?\n\n```typescript\nfunction binarySearch(arr: number[], target: number): number {\n  let left = 0, right = arr.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  return -1;\n}\n\nconst arr = [1, 3, 5, 7, 9, 11];\nconsole.log(binarySearch(arr, 7));\n```",
              "explanation": "Binary search finds 7 at index 3 in the sorted array [1, 3, 5, 7, 9, 11].",
              "reference": "https://en.wikipedia.org/wiki/Binary_search_algorithm",
              "points": 2,
              "answers": [{"text": "3",
                           "is_correct": True},
                          {"text": "7",
                           "is_correct": False},
                          {"text": "4",
                           "is_correct": False},
                          {"text": "-1",
                           "is_correct": False},
                          ],
              },
             {"text": "Which TypeScript generic constraint is correct for a binary search tree implementation?",
              "explanation": "Binary search trees require comparable elements, so extending a type that has comparison methods is essential.",
              "reference": "https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints",
              "points": 2,
              "answers": [{"text": "class BST<T extends Comparable<T>>",
                           "is_correct": True},
                          {"text": "class BST<T extends any>",
                           "is_correct": False},
                          {"text": "class BST<T extends object>",
                           "is_correct": False},
                          {"text": "class BST<T extends string | number>",
                           "is_correct": False},
                          ],
              },
             {"text": "What will this TypeScript heap implementation output?\n\n```typescript\nclass MinHeap {\n  private heap: number[] = [];\n  \n  insert(val: number): void {\n    this.heap.push(val);\n    this.heapifyUp(this.heap.length - 1);\n  }\n  \n  extractMin(): number | undefined {\n    if (this.heap.length === 0) return undefined;\n    if (this.heap.length === 1) return this.heap.pop();\n    \n    const min = this.heap[0];\n    this.heap[0] = this.heap.pop()!;\n    this.heapifyDown(0);\n    return min;\n  }\n  \n  private heapifyUp(index: number): void {\n    const parentIndex = Math.floor((index - 1) / 2);\n    if (parentIndex >= 0 && this.heap[parentIndex] > this.heap[index]) {\n      [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];\n      this.heapifyUp(parentIndex);\n    }\n  }\n  \n  private heapifyDown(index: number): void {\n    const leftChild = 2 * index + 1;\n    const rightChild = 2 * index + 2;\n    let smallest = index;\n    \n    if (leftChild < this.heap.length && this.heap[leftChild] < this.heap[smallest]) {\n      smallest = leftChild;\n    }\n    if (rightChild < this.heap.length && this.heap[rightChild] < this.heap[smallest]) {\n      smallest = rightChild;\n    }\n    \n    if (smallest !== index) {\n      [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];\n      this.heapifyDown(smallest);\n    }\n  }\n}\n\nconst heap = new MinHeap();\nheap.insert(5);\nheap.insert(3);\nheap.insert(8);\nheap.insert(1);\nconsole.log(heap.extractMin());\nconsole.log(heap.extractMin());\n```",
              "explanation": "Min heap maintains the smallest element at the root. After inserting 5, 3, 8, 1, the minimum 1 is extracted first, then 3.",
              "reference": "https://en.wikipedia.org/wiki/Binary_heap",
              "points": 3,
              "answers": [{"text": "1, 3",
                           "is_correct": True},
                          {"text": "5, 3",
                           "is_correct": False},
                          {"text": "1, 5",
                           "is_correct": False},
                          {"text": "3, 1",
                           "is_correct": False},
                          ],
              },
             {"text": "What is the correct TypeScript implementation for checking if a binary tree is balanced?",
              "explanation": "A balanced tree check requires calculating heights and ensuring the difference between left and right subtree heights is at most 1.",
              "reference": "https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree",
              "points": 3,
              "answers": [{"text": "function isBalanced(root: TreeNode | null): boolean {\n  const checkHeight = (node: TreeNode | null): number => {\n    if (!node) return 0;\n    const left = checkHeight(node.left);\n    const right = checkHeight(node.right);\n    if (left === -1 || right === -1 || Math.abs(left - right) > 1) return -1;\n    return Math.max(left, right) + 1;\n  };\n  return checkHeight(root) !== -1;\n}",
                           "is_correct": True,
                           },
                          {"text": "function isBalanced(root: TreeNode | null): boolean {\n  return root === null || (root.left === root.right);\n}",
                           "is_correct": False,
                           },
                          {"text": "function isBalanced(root: TreeNode | null): boolean {\n  return getHeight(root.left) === getHeight(root.right);\n}",
                           "is_correct": False,
                           },
                          {"text": "function isBalanced(root: TreeNode | null): boolean {\n  return root?.left && root?.right ? True : False;\n}",
                           "is_correct": False,
                           },
                          ],
              },
             {"text": "Which TypeScript implementation correctly reverses a linked list?",
              "explanation": "Reversing a linked list requires three pointers: previous, current, and next to iteratively reverse the links.",
              "reference": "https://en.wikipedia.org/wiki/Linked_list",
              "points": 3,
              "answers": [{"text": "function reverse(head: ListNode | null): ListNode | null {\n  let prev = null, curr = head;\n  while (curr) {\n    const next = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = next;\n  }\n  return prev;\n}",
                           "is_correct": True,
                           },
                          {"text": "function reverse(head: ListNode | null): ListNode | null {\n  return head ? head.next = reverse(head.next) : null;\n}",
                           "is_correct": False,
                           },
                          {"text": "function reverse(head: ListNode | null): ListNode | null {\n  const stack: ListNode[] = [];\n  while (head) { stack.push(head); head = head.next; }\n  return stack.pop() || null;\n}",
                           "is_correct": False,
                           },
                          {"text": "function reverse(head: ListNode | null): ListNode | null {\n  if (!head?.next) return head;\n  head.next.next = head;\n  return head.next;\n}",
                           "is_correct": False,
                           },
                          ],
              },
             {"text": "What will this TypeScript graph DFS implementation output for the given graph?\n\n```typescript\nclass Graph {\n  private adjList: Map<string, string[]> = new Map();\n  \n  addEdge(u: string, v: string): void {\n    if (!this.adjList.has(u)) this.adjList.set(u, []);\n    if (!this.adjList.has(v)) this.adjList.set(v, []);\n    this.adjList.get(u)!.push(v);\n    this.adjList.get(v)!.push(u);\n  }\n  \n  dfs(start: string): string[] {\n    const visited = new Set<string>();\n    const result: string[] = [];\n    \n    const dfsHelper = (node: string): void => {\n      visited.add(node);\n      result.push(node);\n      \n      for (const neighbor of this.adjList.get(node) || []) {\n        if (!visited.has(neighbor)) {\n          dfsHelper(neighbor);\n        }\n      }\n    };\n    \n    dfsHelper(start);\n    return result;\n  }\n}\n\nconst graph = new Graph();\ngraph.addEdge('A', 'B');\ngraph.addEdge('A', 'C');\ngraph.addEdge('B', 'D');\nconsole.log(graph.dfs('A').join(','));\n```",
              "explanation": "DFS traverses depth-first. Starting from A, it visits one path completely before backtracking. The exact order depends on the adjacency list order.",
              "reference": "https://en.wikipedia.org/wiki/Depth-first_search",
              "points": 3,
              "answers": [{"text": "A,B,D,C",
                           "is_correct": True},
                          {"text": "A,C,B,D",
                           "is_correct": False},
                          {"text": "A,B,C,D",
                           "is_correct": False},
                          {"text": "D,B,C,A",
                           "is_correct": False},
                          ],
              },
             {"text": "Which TypeScript implementation correctly finds the lowest common ancestor (LCA) in a binary search tree?",
              "explanation": "In a BST, LCA can be found by comparing values: if both nodes are smaller, go left; if both are larger, go right; otherwise, current node is LCA.",
              "reference": "https://en.wikipedia.org/wiki/Lowest_common_ancestor",
              "points": 3,
              "answers": [{"text": "function findLCA(root: TreeNode | null, p: number, q: number): TreeNode | null {\n  if (!root) return null;\n  if (p < root.val && q < root.val) return findLCA(root.left, p, q);\n  if (p > root.val && q > root.val) return findLCA(root.right, p, q);\n  return root;\n}",
                           "is_correct": True,
                           },
                          {"text": "function findLCA(root: TreeNode | null, p: number, q: number): TreeNode | null {\n  return root?.val === p || root?.val === q ? root : null;\n}",
                           "is_correct": False,
                           },
                          {"text": "function findLCA(root: TreeNode | null, p: number, q: number): TreeNode | null {\n  return root?.left || root?.right;\n}",
                           "is_correct": False,
                           },
                          {"text": "function findLCA(root: TreeNode | null, p: number, q: number): TreeNode | null {\n  if (!root || root.val === Math.min(p, q)) return root;\n  return findLCA(root.left, p, q) || findLCA(root.right, p, q);\n}",
                           "is_correct": False,
                           },
                          ],
              },
             {"text": "What is the time complexity of this TypeScript implementation for checking if a string has balanced parentheses?\n\n```typescript\nfunction isBalanced(s: string): boolean {\n  const stack: string[] = [];\n  const pairs: Record<string, string> = { '(': ')', '[': ']', '{': '}' };\n  \n  for (const char of s) {\n    if (char in pairs) {\n      stack.push(char);\n    } else if (Object.values(pairs).includes(char)) {\n      if (stack.length === 0 || pairs[stack.pop()!] !== char) {\n        return False;\n      }\n    }\n  }\n  \n  return stack.length === 0;\n}\n```",
              "explanation": "The algorithm iterates through the string once, performing constant time operations (push/pop) for each character, resulting in O(n) time complexity.",
              "reference": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)",
              "points": 2,
              "answers": [{"text": "O(n)",
                           "is_correct": True},
                          {"text": "O(n²)",
                           "is_correct": False},
                          {"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(1)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which TypeScript implementation correctly merges two sorted linked lists?",
              "explanation": "Merging two sorted lists requires comparing values and linking nodes in order, handling remaining nodes when one list is exhausted.",
              "reference": "https://en.wikipedia.org/wiki/Merge_algorithm",
              "points": 3,
              "answers": [{"text": "function merge(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n  const dummy = new ListNode(0);\n  let current = dummy;\n  \n  while (l1 && l2) {\n    if (l1.val <= l2.val) {\n      current.next = l1;\n      l1 = l1.next;\n    } else {\n      current.next = l2;\n      l2 = l2.next;\n    }\n    current = current.next;\n  }\n  \n  current.next = l1 || l2;\n  return dummy.next;\n}",
                           "is_correct": True,
                           },
                          {"text": "function merge(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n  return l1 ? l1 : l2;\n}",
                           "is_correct": False,
                           },
                          {"text": "function merge(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n  if (!l1 || !l2) return null;\n  l1.next = l2;\n  return l1;\n}",
                           "is_correct": False,
                           },
                          {"text": "function merge(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n  const result = l1?.val < l2?.val ? l1 : l2;\n  return result;\n}",
                           "is_correct": False,
                           },
                          ],
              },
             {"text": "What will this TypeScript trie implementation output?\n\n```typescript\nclass TrieNode {\n  children: Map<string, TrieNode> = new Map();\n  isEndOfWord = False;\n}\n\nclass Trie {\n  private root = new TrieNode();\n  \n  insert(word: string): void {\n    let current = this.root;\n    for (const char of word) {\n      if (!current.children.has(char)) {\n        current.children.set(char, new TrieNode());\n      }\n      current = current.children.get(char)!;\n    }\n    current.isEndOfWord = True;\n  }\n  \n  search(word: string): boolean {\n    let current = this.root;\n    for (const char of word) {\n      if (!current.children.has(char)) {\n        return False;\n      }\n      current = current.children.get(char)!;\n    }\n    return current.isEndOfWord;\n  }\n}\n\nconst trie = new Trie();\ntrie.insert('cat');\ntrie.insert('car');\nconsole.log(trie.search('ca'));\nconsole.log(trie.search('cat'));\n```",
              "explanation": "The trie stores 'cat' and 'car'. Searching 'ca' returns False (not a complete word), while searching 'cat' returns True (complete word).",
              "reference": "https://en.wikipedia.org/wiki/Trie",
              "points": 3,
              "answers": [{"text": "False, True",
                           "is_correct": True},
                          {"text": "True, True",
                           "is_correct": False},
                          {"text": "False, False",
                           "is_correct": False},
                          {"text": "True, False",
                           "is_correct": False},
                          ],
              },
             {"text": "Which TypeScript implementation correctly performs an iterative in-order traversal of a binary tree?",
              "explanation": "Iterative in-order traversal uses a stack to simulate recursion, going left first, processing node, then going right.",
              "reference": "https://en.wikipedia.org/wiki/Tree_traversal",
              "points": 3,
              "answers": [{"text": "function inorderTraversal(root: TreeNode | null): number[] {\n  const result: number[] = [];\n  const stack: TreeNode[] = [];\n  let current = root;\n  \n  while (current || stack.length > 0) {\n    while (current) {\n      stack.push(current);\n      current = current.left;\n    }\n    current = stack.pop()!;\n    result.push(current.val);\n    current = current.right;\n  }\n  \n  return result;\n}",
                           "is_correct": True,
                           },
                          {"text": "function inorderTraversal(root: TreeNode | null): number[] {\n  const result: number[] = [];\n  const stack = [root];\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (node) result.push(node.val);\n  }\n  return result;\n}",
                           "is_correct": False,
                           },
                          {"text": "function inorderTraversal(root: TreeNode | null): number[] {\n  if (!root) return [];\n  return [root.val, ...inorderTraversal(root.left), ...inorderTraversal(root.right)];\n}",
                           "is_correct": False,
                           },
                          {"text": "function inorderTraversal(root: TreeNode | null): number[] {\n  const result: number[] = [];\n  if (root) {\n    result.push(root.val);\n    result.push(...inorderTraversal(root.left));\n    result.push(...inorderTraversal(root.right));\n  }\n  return result;\n}",
                           "is_correct": False,
                           },
                          ],
              },
             {"text": "What is the space complexity of this TypeScript quicksort implementation?\n\n```typescript\nfunction quickSort(arr: number[]): number[] {\n  if (arr.length <= 1) return arr;\n  \n  const pivot = arr[Math.floor(arr.length / 2)];\n  const left = arr.filter(x => x < pivot);\n  const middle = arr.filter(x => x === pivot);\n  const right = arr.filter(x => x > pivot);\n  \n  return [...quickSort(left), ...middle, ...quickSort(right)];\n}\n```",
              "explanation": "This implementation creates new arrays at each recursion level, using O(n log n) space on average due to the recursion depth and new array creation.",
              "reference": "https://en.wikipedia.org/wiki/Quicksort",
              "points": 2,
              "answers": [{"text": "O(n log n)",
                           "is_correct": True},
                          {"text": "O(log n)",
                           "is_correct": False},
                          {"text": "O(n)",
                           "is_correct": False},
                          {"text": "O(1)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which TypeScript implementation correctly detects a cycle in a linked list using Floyd's algorithm?",
              "explanation": "Floyd's cycle detection uses two pointers moving at different speeds. If there's a cycle, the fast pointer will eventually meet the slow pointer.",
              "reference": "https://en.wikipedia.org/wiki/Cycle_detection",
              "points": 3,
              "answers": [{"text": "function hasCycle(head: ListNode | null): boolean {\n  if (!head || !head.next) return False;\n  \n  let slow = head;\n  let fast = head.next;\n  \n  while (fast && fast.next) {\n    if (slow === fast) return True;\n    slow = slow.next!;\n    fast = fast.next.next;\n  }\n  \n  return False;\n}",
                           "is_correct": True,
                           },
                          {"text": "function hasCycle(head: ListNode | null): boolean {\n  const visited = new Set();\n  while (head) {\n    if (visited.has(head)) return True;\n    visited.add(head);\n    head = head.next;\n  }\n  return False;\n}",
                           "is_correct": False,
                           },
                          {"text": "function hasCycle(head: ListNode | null): boolean {\n  return head?.next === head;\n}",
                           "is_correct": False,
                           },
                          {"text": "function hasCycle(head: ListNode | null): boolean {\n  let count = 0;\n  while (head && count < 1000) {\n    head = head.next;\n    count++;\n  }\n  return count === 1000;\n}",
                           "is_correct": False,
                           },
                          ],
              },
             {"text": "What will this TypeScript LRU Cache implementation output?\n\n```typescript\nclass LRUCache {\n  private capacity: number;\n  private cache = new Map<number, number>();\n  \n  constructor(capacity: number) {\n    this.capacity = capacity;\n  }\n  \n  get(key: number): number {\n    if (this.cache.has(key)) {\n      const value = this.cache.get(key)!;\n      this.cache.delete(key);\n      this.cache.set(key, value);\n      return value;\n    }\n    return -1;\n  }\n  \n  put(key: number, value: number): void {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.capacity) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    this.cache.set(key, value);\n  }\n}\n\nconst lru = new LRUCache(2);\nlru.put(1, 1);\nlru.put(2, 2);\nconsole.log(lru.get(1));\nlru.put(3, 3);\nconsole.log(lru.get(2));\n```",
              "explanation": "LRU Cache with capacity 2: put(1,1), put(2,2), get(1) returns 1 and makes 1 most recent, put(3,3) evicts 2, so get(2) returns -1.",
              "reference": "https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)",
              "points": 3,
              "answers": [{"text": "1, -1",
                           "is_correct": True},
                          {"text": "1, 2",
                           "is_correct": False},
                          {"text": "-1, -1",
                           "is_correct": False},
                          {"text": "2, 1",
                           "is_correct": False},
                          ],
              },
             {"text": "Which TypeScript implementation correctly finds the maximum depth of a binary tree?",
              "explanation": "Maximum depth is calculated recursively by taking the maximum of left and right subtree depths and adding 1 for the current level.",
              "reference": "https://en.wikipedia.org/wiki/Binary_tree",
              "points": 2,
              "answers": [{"text": "function maxDepth(root: TreeNode | null): number {\n  if (!root) return 0;\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n}",
                           "is_correct": True,
                           },
                          {"text": "function maxDepth(root: TreeNode | null): number {\n  return root ? 1 : 0;\n}",
                           "is_correct": False,
                           },
                          {"text": "function maxDepth(root: TreeNode | null): number {\n  if (!root) return 0;\n  return maxDepth(root.left) + maxDepth(root.right);\n}",
                           "is_correct": False,
                           },
                          {"text": "function maxDepth(root: TreeNode | null): number {\n  return root ? Math.min(maxDepth(root.left), maxDepth(root.right)) + 1 : 0;\n}",
                           "is_correct": False,
                           },
                          ],
              },
             {"text": "What is the output of this TypeScript implementation for finding two sum in a sorted array?\n\n```typescript\nfunction twoSum(numbers: number[], target: number): number[] {\n  let left = 0;\n  let right = numbers.length - 1;\n  \n  while (left < right) {\n    const sum = numbers[left] + numbers[right];\n    if (sum === target) {\n      return [left + 1, right + 1]; // 1-indexed\n    } else if (sum < target) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  \n  return [];\n}\n\nconst nums = [2, 7, 11, 15];\nconsole.log(twoSum(nums, 9));\n```",
              "explanation": "Two pointers approach: 2 + 7 = 9 (target), found at indices 0 and 1, but returning 1-indexed positions [1, 2].",
              "reference": "https://en.wikipedia.org/wiki/Two_pointers_technique",
              "points": 2,
              "answers": [{"text": "[1, 2]",
                           "is_correct": True},
                          {"text": "[0, 1]",
                           "is_correct": False},
                          {"text": "[2, 7]",
                           "is_correct": False},
                          {"text": "[]",
                           "is_correct": False},
                          ],
              },
             {"text": "Which TypeScript implementation correctly validates if a binary tree is a valid BST?",
              "explanation": "A valid BST requires checking that each node's value is within a valid range determined by its ancestors.",
              "reference": "https://en.wikipedia.org/wiki/Binary_search_tree",
              "points": 3,
              "answers": [{"text": "function isValidBST(root: TreeNode | null, min = -Infinity, max = Infinity): boolean {\n  if (!root) return True;\n  if (root.val <= min || root.val >= max) return False;\n  return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\n}",
                           "is_correct": True,
                           },
                          {"text": "function isValidBST(root: TreeNode | null): boolean {\n  if (!root) return True;\n  return (!root.left || root.left.val < root.val) && (!root.right || root.right.val > root.val);\n}",
                           "is_correct": False,
                           },
                          {"text": "function isValidBST(root: TreeNode | null): boolean {\n  return root === null || (root.left && root.right);\n}",
                           "is_correct": False,
                           },
                          {"text": "function isValidBST(root: TreeNode | null): boolean {\n  const inorder = inorderTraversal(root);\n  return inorder.every((val, i) => i === 0 || val > inorder[i - 1]);\n}",
                           "is_correct": False,
                           },
                          ],
              },
             {"text": "What is the time complexity of this TypeScript implementation for finding the kth largest element?\n\n```typescript\nfunction findKthLargest(nums: number[], k: number): number {\n  const minHeap: number[] = [];\n  \n  const heapifyUp = (index: number): void => {\n    const parentIndex = Math.floor((index - 1) / 2);\n    if (parentIndex >= 0 && minHeap[parentIndex] > minHeap[index]) {\n      [minHeap[parentIndex], minHeap[index]] = [minHeap[index], minHeap[parentIndex]];\n      heapifyUp(parentIndex);\n    }\n  };\n  \n  const heapifyDown = (index: number): void => {\n    const leftChild = 2 * index + 1;\n    const rightChild = 2 * index + 2;\n    let smallest = index;\n    \n    if (leftChild < minHeap.length && minHeap[leftChild] < minHeap[smallest]) {\n      smallest = leftChild;\n    }\n    if (rightChild < minHeap.length && minHeap[rightChild] < minHeap[smallest]) {\n      smallest = rightChild;\n    }\n    \n    if (smallest !== index) {\n      [minHeap[index], minHeap[smallest]] = [minHeap[smallest], minHeap[index]];\n      heapifyDown(smallest);\n    }\n  };\n  \n  for (const num of nums) {\n    if (minHeap.length < k) {\n      minHeap.push(num);\n      heapifyUp(minHeap.length - 1);\n    } else if (num > minHeap[0]) {\n      minHeap[0] = num;\n      heapifyDown(0);\n    }\n  }\n  \n  return minHeap[0];\n}\n```",
              "explanation": "This min-heap approach maintains a heap of size k, processing each element once with O(log k) operations, resulting in O(n log k) time complexity.",
              "reference": "https://en.wikipedia.org/wiki/Selection_algorithm",
              "points": 2,
              "answers": [{"text": "O(n log k)",
                           "is_correct": True},
                          {"text": "O(n log n)",
                           "is_correct": False},
                          {"text": "O(nk)",
                           "is_correct": False},
                          {"text": "O(k)",
                           "is_correct": False},
                          ],
              },
             {"text": "Which TypeScript union type correctly represents the possible states of a tree node in a red-black tree?",
              "explanation": "Red-black trees use color coding with specific rules. Nodes can be either red or black, and this should be represented as a union type.",
              "reference": "https://en.wikipedia.org/wiki/Red%E2%80%93black_tree",
              "points": 2,
              "answers": [{"text": "type Color = 'RED' | 'BLACK';",
                           "is_correct": True},
                          {"text": "type Color = boolean;",
                           "is_correct": False},
                          {"text": "type Color = 0 | 1 | 2;",
                           "is_correct": False},
                          {"text": "type Color = string;",
                           "is_correct": False},
                          ],
              },
             {"text": "What will this TypeScript sliding window implementation output?\n\n```typescript\nfunction maxSlidingWindow(nums: number[], k: number): number[] {\n  const result: number[] = [];\n  const deque: number[] = []; // stores indices\n  \n  for (let i = 0; i < nums.length; i++) {\n    // Remove indices outside current window\n    while (deque.length > 0 && deque[0] <= i - k) {\n      deque.shift();\n    }\n    \n    // Remove indices whose values are smaller than current\n    while (deque.length > 0 && nums[deque[deque.length - 1]] <= nums[i]) {\n      deque.pop();\n    }\n    \n    deque.push(i);\n    \n    // Add to result if window is complete\n    if (i >= k - 1) {\n      result.push(nums[deque[0]]);\n    }\n  }\n  \n  return result;\n}\n\nconst nums = [1, 3, -1, -3, 5, 3, 6, 7];\nconsole.log(maxSlidingWindow(nums, 3));\n```",
              "explanation": "Sliding window maximum with deque: windows [1,3,-1]→3, [3,-1,-3]→3, [-1,-3,5]→5, [-3,5,3]→5, [5,3,6]→6, [3,6,7]→7.",
              "reference": "https://en.wikipedia.org/wiki/Sliding_window_protocol",
              "points": 3,
              "answers": [{"text": "[3, 3, 5, 5, 6, 7]",
                           "is_correct": True},
                          {"text": "[1, 3, 5, 5, 6, 7]",
                           "is_correct": False},
                          {"text": "[3, 3, 3, 5, 6, 7]",
                           "is_correct": False},
                          {"text": "[1, 1, -1, 3, 5, 6]",
                           "is_correct": False},
                          ],
              },
             {"text": "Which TypeScript implementation correctly performs a level-order traversal (BFS) of a binary tree?",
              "explanation": "Level-order traversal uses a queue to process nodes level by level, ensuring breadth-first exploration of the tree.",
              "reference": "https://en.wikipedia.org/wiki/Tree_traversal",
              "points": 3,
              "answers": [{"text": "function levelOrder(root: TreeNode | null): number[][] {\n  if (!root) return [];\n  const result: number[][] = [];\n  const queue: TreeNode[] = [root];\n  \n  while (queue.length > 0) {\n    const levelSize = queue.length;\n    const currentLevel: number[] = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift()!;\n      currentLevel.push(node.val);\n      \n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    \n    result.push(currentLevel);\n  }\n  \n  return result;\n}",
                           "is_correct": True,
                           },
                          {"text": "function levelOrder(root: TreeNode | null): number[][] {\n  const result: number[][] = [];\n  const dfs = (node: TreeNode | null, level: number): void => {\n    if (!node) return;\n    if (!result[level]) result[level] = [];\n    result[level].push(node.val);\n    dfs(node.left, level + 1);\n    dfs(node.right, level + 1);\n  };\n  dfs(root, 0);\n  return result;\n}",
                           "is_correct": False,
                           },
                          {"text": "function levelOrder(root: TreeNode | null): number[][] {\n  if (!root) return [];\n  return [[root.val], ...levelOrder(root.left), ...levelOrder(root.right)];\n}",
                           "is_correct": False,
                           },
                          {"text": "function levelOrder(root: TreeNode | null): number[][] {\n  const stack = [root];\n  const result: number[][] = [];\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (node) result.push([node.val]);\n  }\n  return result;\n}",
                           "is_correct": False,
                           },
                          ],
              },
             {"text": "What is the output of this TypeScript implementation for the longest palindromic substring?\n\n```typescript\nfunction longestPalindrome(s: string): string {\n  if (s.length <= 1) return s;\n  \n  let longest = s[0];\n  \n  const expandAroundCenter = (left: number, right: number): string => {\n    while (left >= 0 && right < s.length && s[left] === s[right]) {\n      left--;\n      right++;\n    }\n    return s.substring(left + 1, right);\n  };\n  \n  for (let i = 0; i < s.length; i++) {\n    // Check for odd length palindromes\n    const oddPalindrome = expandAroundCenter(i, i);\n    if (oddPalindrome.length > longest.length) {\n      longest = oddPalindrome;\n    }\n    \n    // Check for even length palindromes\n    const evenPalindrome = expandAroundCenter(i, i + 1);\n    if (evenPalindrome.length > longest.length) {\n      longest = evenPalindrome;\n    }\n  }\n  \n  return longest;\n}\n\nconsole.log(longestPalindrome('babad'));\n```",
              "explanation": "The algorithm expands around each center. For 'babad', it finds 'bab' (or 'aba') as the longest palindrome of length 3.",
              "reference": "https://en.wikipedia.org/wiki/Longest_palindromic_substring",
              "points": 3,
              "answers": [{"text": "bab",
                           "is_correct": True},
                          {"text": "aba",
                           "is_correct": False},
                          {"text": "babad",
                           "is_correct": False},
                          {"text": "b",
                           "is_correct": False},
                          ],
              },
             {"text": "Which TypeScript implementation correctly counts the number of islands in a 2D grid?\n\n```typescript\nfunction numIslands(grid: string[][]): number {\n  if (!grid || grid.length === 0) return 0;\n  \n  const rows = grid.length;\n  const cols = grid[0].length;\n  let islands = 0;\n  \n  const dfs = (row: number, col: number): void => {\n    if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] === '0') {\n      return;\n    }\n    \n    grid[row][col] = '0'; // Mark as visited\n    \n    // Explore all 4 directions\n    dfs(row + 1, col);\n    dfs(row - 1, col);\n    dfs(row, col + 1);\n    dfs(row, col - 1);\n  };\n  \n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === '1') {\n        islands++;\n        dfs(i, j);\n      }\n    }\n  }\n  \n  return islands;\n}\n```\n\nWhat will this return for grid = [['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]?",
              "explanation": "The grid has 3 distinct islands: top-left 2x2 island, middle single cell, and bottom-right 1x2 island.",
              "reference": "https://en.wikipedia.org/wiki/Depth-first_search",
              "points": 3,
              "answers": [{"text": "3",
                           "is_correct": True},
                          {"text": "4",
                           "is_correct": False},
                          {"text": "2",
                           "is_correct": False},
                          {"text": "5",
                           "is_correct": False},
                          ],
              },
             ]
